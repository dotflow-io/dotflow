{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to dotflow Website \u2022 Documentation \u2022 Pypi With Dotflow, you get a powerful and easy-to-use library designed to create execution pipelines without complication. Add tasks intuitively and control the entire process with just a few commands. Our goal is to make task management faster and more secure, without overwhelming you with complexity. Simply instantiate the DotFlow class, add your tasks with the add method, and start execution with the start method. Start with the basics here . Getting Help We use GitHub issues for tracking bugs and feature requests and have limited bandwidth to address them. If you need anything, I ask you to please follow our templates for opening issues or discussions. \ud83d\udc1b Bug Report \ud83d\udcd5 Documentation Issue \ud83d\ude80 Feature Request \ud83d\udcac General Question Commit Style \u2699\ufe0f FEATURE \ud83d\udcdd PEP8 \ud83d\udccc ISSUE \ud83e\udeb2 BUG \ud83d\udcd8 DOCS \ud83d\udce6 PyPI \u2764\ufe0f\ufe0f TEST \u2b06\ufe0f CI/CD \u26a0\ufe0f SECURITY License This project is licensed under the terms of the MIT License.","title":"Home"},{"location":"#welcome-to-dotflow","text":"Website \u2022 Documentation \u2022 Pypi With Dotflow, you get a powerful and easy-to-use library designed to create execution pipelines without complication. Add tasks intuitively and control the entire process with just a few commands. Our goal is to make task management faster and more secure, without overwhelming you with complexity. Simply instantiate the DotFlow class, add your tasks with the add method, and start execution with the start method. Start with the basics here .","title":"Welcome to dotflow"},{"location":"#getting-help","text":"We use GitHub issues for tracking bugs and feature requests and have limited bandwidth to address them. If you need anything, I ask you to please follow our templates for opening issues or discussions. \ud83d\udc1b Bug Report \ud83d\udcd5 Documentation Issue \ud83d\ude80 Feature Request \ud83d\udcac General Question","title":"Getting Help"},{"location":"#commit-style","text":"\u2699\ufe0f FEATURE \ud83d\udcdd PEP8 \ud83d\udccc ISSUE \ud83e\udeb2 BUG \ud83d\udcd8 DOCS \ud83d\udce6 PyPI \u2764\ufe0f\ufe0f TEST \u2b06\ufe0f CI/CD \u26a0\ufe0f SECURITY","title":"Commit Style"},{"location":"#license","text":"This project is licensed under the terms of the MIT License.","title":"License"},{"location":"nav/development/development-guide/","text":"Development Guide Getting Help We use GitHub issues for tracking bugs and feature requests and have limited bandwidth to address them. If you need anything, I ask you to please follow our templates for opening issues or discussions. \ud83d\udc1b Bug Report \ud83d\udcd5 Documentation Issue \ud83d\ude80 Feature Request \ud83d\udcac General Question Commit Style \u2699\ufe0f FEATURE \ud83d\udcdd PEP8 \ud83d\udccc ISSUE \ud83e\udeb2 BUG \ud83d\udcd8 DOCS \ud83d\udce6 PyPI \u2764\ufe0f\ufe0f TEST \u2b06\ufe0f CI/CD \u26a0\ufe0f SECURITY","title":"Development Guide"},{"location":"nav/development/development-guide/#development-guide","text":"","title":"Development Guide"},{"location":"nav/development/development-guide/#getting-help","text":"We use GitHub issues for tracking bugs and feature requests and have limited bandwidth to address them. If you need anything, I ask you to please follow our templates for opening issues or discussions. \ud83d\udc1b Bug Report \ud83d\udcd5 Documentation Issue \ud83d\ude80 Feature Request \ud83d\udcac General Question","title":"Getting Help"},{"location":"nav/development/development-guide/#commit-style","text":"\u2699\ufe0f FEATURE \ud83d\udcdd PEP8 \ud83d\udccc ISSUE \ud83e\udeb2 BUG \ud83d\udcd8 DOCS \ud83d\udce6 PyPI \u2764\ufe0f\ufe0f TEST \u2b06\ufe0f CI/CD \u26a0\ufe0f SECURITY","title":"Commit Style"},{"location":"nav/development/release-notes/","text":"Release Notes v0.13.0 \ud83d\udce6 PyPI - Build 0.13.0 \ud83d\udccc Action with timeout, retry_delay and backoff \ud83d\udccc Notification with Telegram v0.12.0 \ud83d\udce6 PyPI - Build 0.12.0 \ud83d\udccc Separate tasks into groups \ud83d\udccc Workflow result v0.11.1 \ud83d\udce6 PyPI - Build 0.11.1 \ud83e\udeb2 BUG: Problem with context of type 'pydantic class' v0.11.0 \ud83d\udce6 PyPI - Build 0.11.0 v0.10.0 \ud83d\udce6 PyPI - Build 0.10.0 \ud83d\udccc Storage MongoDB \ud83d\udccc ABC Config / Storage \ud83d\udccc Update Documentation v0.9.1 \ud83d\udce6 PyPI - Build 0.9.1 \ud83e\udeb2 BUG: Fixed ImportError NoneType Python 3.9 v0.9.0 \ud83d\udce6 PyPI - Build 0.9.0 \ud83d\udccc Bulk task inclusion option v0.8.2 \ud83d\udce6 PyPI - Build 0.8.2 \ud83e\udeb2 Fixed class-type step without init v0.8.1 \ud83d\udce6 PyPI - Build 0.8.1 \ud83e\udeb2 Fixed context switching v0.8.0 \ud83d\udce6 PyPI - Build 0.8.0 \ud83d\udccc Create CLI to manage workflow v0.7.0 \ud83d\udce6 PyPI - Build 0.7.0 \ud83d\udccc Communication layer implementation v0.6.0 \ud83d\udce6 PyPI - Build 0.6.0 v0.5.0 \ud83d\udce6 PyPI - Build 0.5.1 \ud83d\udccc CLI - Command-Line Interface \ud83d\udccc Step adaptation with class structure v0.4.1 \ud83d\udce6 PyPI - Build 0.4.1 v0.4.0 \ud83d\udce6 PyPI - Build 0.4.0 \ud83d\udccc Improvement of the API to start the workflow task \ud83d\udccc Improved API interface for decorators \ud83d\udccc Improvement unit tests v0.3.0 \ud83d\udce6 PyPI - Build 0.3.0 \ud83d\udccc Improvement of the API to start the workflow task v0.2.0 \ud83d\udce6 PyPI - Build 0.2.0 \ud83d\udccc Create documentation \ud83d\udccc Import of the context class v0.1.0 \ud83d\udce6 PyPI - Build 0.1.0","title":"Release Notes"},{"location":"nav/development/release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"nav/development/release-notes/#v0130","text":"\ud83d\udce6 PyPI - Build 0.13.0 \ud83d\udccc Action with timeout, retry_delay and backoff \ud83d\udccc Notification with Telegram","title":"v0.13.0"},{"location":"nav/development/release-notes/#v0120","text":"\ud83d\udce6 PyPI - Build 0.12.0 \ud83d\udccc Separate tasks into groups \ud83d\udccc Workflow result","title":"v0.12.0"},{"location":"nav/development/release-notes/#v0111","text":"\ud83d\udce6 PyPI - Build 0.11.1 \ud83e\udeb2 BUG: Problem with context of type 'pydantic class'","title":"v0.11.1"},{"location":"nav/development/release-notes/#v0110","text":"\ud83d\udce6 PyPI - Build 0.11.0","title":"v0.11.0"},{"location":"nav/development/release-notes/#v0100","text":"\ud83d\udce6 PyPI - Build 0.10.0 \ud83d\udccc Storage MongoDB \ud83d\udccc ABC Config / Storage \ud83d\udccc Update Documentation","title":"v0.10.0"},{"location":"nav/development/release-notes/#v091","text":"\ud83d\udce6 PyPI - Build 0.9.1 \ud83e\udeb2 BUG: Fixed ImportError NoneType Python 3.9","title":"v0.9.1"},{"location":"nav/development/release-notes/#v090","text":"\ud83d\udce6 PyPI - Build 0.9.0 \ud83d\udccc Bulk task inclusion option","title":"v0.9.0"},{"location":"nav/development/release-notes/#v082","text":"\ud83d\udce6 PyPI - Build 0.8.2 \ud83e\udeb2 Fixed class-type step without init","title":"v0.8.2"},{"location":"nav/development/release-notes/#v081","text":"\ud83d\udce6 PyPI - Build 0.8.1 \ud83e\udeb2 Fixed context switching","title":"v0.8.1"},{"location":"nav/development/release-notes/#v080","text":"\ud83d\udce6 PyPI - Build 0.8.0 \ud83d\udccc Create CLI to manage workflow","title":"v0.8.0"},{"location":"nav/development/release-notes/#v070","text":"\ud83d\udce6 PyPI - Build 0.7.0 \ud83d\udccc Communication layer implementation","title":"v0.7.0"},{"location":"nav/development/release-notes/#v060","text":"\ud83d\udce6 PyPI - Build 0.6.0","title":"v0.6.0"},{"location":"nav/development/release-notes/#v050","text":"\ud83d\udce6 PyPI - Build 0.5.1 \ud83d\udccc CLI - Command-Line Interface \ud83d\udccc Step adaptation with class structure","title":"v0.5.0"},{"location":"nav/development/release-notes/#v041","text":"\ud83d\udce6 PyPI - Build 0.4.1","title":"v0.4.1"},{"location":"nav/development/release-notes/#v040","text":"\ud83d\udce6 PyPI - Build 0.4.0 \ud83d\udccc Improvement of the API to start the workflow task \ud83d\udccc Improved API interface for decorators \ud83d\udccc Improvement unit tests","title":"v0.4.0"},{"location":"nav/development/release-notes/#v030","text":"\ud83d\udce6 PyPI - Build 0.3.0 \ud83d\udccc Improvement of the API to start the workflow task","title":"v0.3.0"},{"location":"nav/development/release-notes/#v020","text":"\ud83d\udce6 PyPI - Build 0.2.0 \ud83d\udccc Create documentation \ud83d\udccc Import of the context class","title":"v0.2.0"},{"location":"nav/development/release-notes/#v010","text":"\ud83d\udce6 PyPI - Build 0.1.0","title":"v0.1.0"},{"location":"nav/learn/dotflow-cli/","text":"Dotflow CLI May 4, 2025 The Dotflow CLI (Command-Line Interface) is a feature that simplifies the execution of workflows in environments that require running through terminal commands. Simple Start dotflow start --step examples.cli_with_mode.simple_step With Initial Context dotflow start --step examples.cli_with_initial_context.simple_step --initial-context abc With Callback dotflow start --step examples.cli_with_callback.simple_step --callback examples.cli_with_callback.callback With Mode dotflow start --step examples.cli_with_mode.simple_step --mode sequential dotflow start --step examples.cli_with_mode.simple_step --mode background dotflow start --step examples.cli_with_mode.simple_step --mode parallel","title":"Dotflow CLI"},{"location":"nav/learn/dotflow-cli/#dotflow-cli","text":"May 4, 2025 The Dotflow CLI (Command-Line Interface) is a feature that simplifies the execution of workflows in environments that require running through terminal commands.","title":"Dotflow CLI"},{"location":"nav/learn/dotflow-cli/#simple-start","text":"dotflow start --step examples.cli_with_mode.simple_step","title":"Simple Start"},{"location":"nav/learn/dotflow-cli/#with-initial-context","text":"dotflow start --step examples.cli_with_initial_context.simple_step --initial-context abc","title":"With Initial Context"},{"location":"nav/learn/dotflow-cli/#with-callback","text":"dotflow start --step examples.cli_with_callback.simple_step --callback examples.cli_with_callback.callback","title":"With Callback"},{"location":"nav/learn/dotflow-cli/#with-mode","text":"dotflow start --step examples.cli_with_mode.simple_step --mode sequential dotflow start --step examples.cli_with_mode.simple_step --mode background dotflow start --step examples.cli_with_mode.simple_step --mode parallel","title":"With Mode"},{"location":"nav/learn/examples/","text":"More Examples May 11, 2025 Github: dotflow/examples Example Command cli_with_callback dotflow start --step examples.cli_with_callback.simple_step --callback examples.cli_with_callback.callback cli_with_initial_context dotflow start --step examples.cli_with_initial_context.simple_step --initial-context abc cli_with_mode dotflow start --step examples.cli_with_mode.simple_step --mode sequential cli_with_output_context dotflow start --step examples.cli_with_output_context.simple_step --storage file cli_with_path dotflow start --step examples.cli_with_path.simple_step --path .storage --storage file flow python examples/flow.py simple_class_workflow python examples/simple_class_workflow.py simple_cli dotflow start --step examples.simple_cli.simple_step simple_function_workflow python examples/simple_function_workflow.py simple_function_workflow_with_error python examples/simple_function_workflow_with_error.py step_class_result_context python examples/step_class_result_context.py step_class_result_storage python examples/step_class_result_storage.py step_class_result_task python examples/step_class_result_task.py step_function_result_context python examples/step_function_result_context.py step_function_result_storage python examples/step_function_result_storage.py step_function_result_task python examples/step_function_result_task.py step_with_groups python examples/step_with_groups.py step_with_initial_context python examples/step_with_initial_context.py step_with_many_contexts python examples/step_with_many_contexts.py step_with_notify_telegram python examples/step_with_notify_telegram.py step_with_previous_context python examples/step_with_previous_context.py step_with_storage_file python examples/step_with_storage_file.py step_with_storage_mongodb python examples/step_with_storage_mongodb.py workflow_background_mode python examples/workflow_background_mode.py workflow_keep_going_true python examples/workflow_keep_going_true.py workflow_parallel_mode python examples/workflow_parallel_mode.py workflow_sequential_group_mode python examples/workflow_sequential_group_mode.py workflow_sequential_mode python examples/workflow_sequential_mode.py workflow_step_callback python examples/workflow_step_callback.py workflow_with_backoff python examples/workflow_with_backoff.py workflow_with_callback_failure python examples/workflow_with_callback_failure.py workflow_with_callback_success python examples/workflow_with_callback_success.py workflow_with_retry python examples/workflow_with_retry.py workflow_with_retry_delay python examples/workflow_with_retry_delay.py workflow_with_timeout python examples/workflow_with_timeout.py","title":"More Examples"},{"location":"nav/learn/examples/#more-examples","text":"May 11, 2025 Github: dotflow/examples Example Command cli_with_callback dotflow start --step examples.cli_with_callback.simple_step --callback examples.cli_with_callback.callback cli_with_initial_context dotflow start --step examples.cli_with_initial_context.simple_step --initial-context abc cli_with_mode dotflow start --step examples.cli_with_mode.simple_step --mode sequential cli_with_output_context dotflow start --step examples.cli_with_output_context.simple_step --storage file cli_with_path dotflow start --step examples.cli_with_path.simple_step --path .storage --storage file flow python examples/flow.py simple_class_workflow python examples/simple_class_workflow.py simple_cli dotflow start --step examples.simple_cli.simple_step simple_function_workflow python examples/simple_function_workflow.py simple_function_workflow_with_error python examples/simple_function_workflow_with_error.py step_class_result_context python examples/step_class_result_context.py step_class_result_storage python examples/step_class_result_storage.py step_class_result_task python examples/step_class_result_task.py step_function_result_context python examples/step_function_result_context.py step_function_result_storage python examples/step_function_result_storage.py step_function_result_task python examples/step_function_result_task.py step_with_groups python examples/step_with_groups.py step_with_initial_context python examples/step_with_initial_context.py step_with_many_contexts python examples/step_with_many_contexts.py step_with_notify_telegram python examples/step_with_notify_telegram.py step_with_previous_context python examples/step_with_previous_context.py step_with_storage_file python examples/step_with_storage_file.py step_with_storage_mongodb python examples/step_with_storage_mongodb.py workflow_background_mode python examples/workflow_background_mode.py workflow_keep_going_true python examples/workflow_keep_going_true.py workflow_parallel_mode python examples/workflow_parallel_mode.py workflow_sequential_group_mode python examples/workflow_sequential_group_mode.py workflow_sequential_mode python examples/workflow_sequential_mode.py workflow_step_callback python examples/workflow_step_callback.py workflow_with_backoff python examples/workflow_with_backoff.py workflow_with_callback_failure python examples/workflow_with_callback_failure.py workflow_with_callback_success python examples/workflow_with_callback_success.py workflow_with_retry python examples/workflow_with_retry.py workflow_with_retry_delay python examples/workflow_with_retry_delay.py workflow_with_timeout python examples/workflow_with_timeout.py","title":"More Examples"},{"location":"nav/learn/getting-started/","text":"Getting Started February 10, 2025 Install To install Dotflow , run the following command from the command line: With Pip pip install dotflow With Poetry poetry add dotflow First Steps The simplest file could look like this: from dotflow import DotFlow, action def my_callback(*args, **kwargs): print(args, kwargs) @action def my_task(): print(\"task\") workflow = DotFlow() workflow.task.add(step=my_task, callback=my_callback) workflow.start() 1. Import Start with the basics, which is importing the necessary classes and methods. ( DotFlow , action ) from dotflow import DotFlow, action 2. Callback function Create a my_callback function to receive execution information of a task. It is not necessary to include this function, as you will still have a report at the end of the execution in the instantiated object of the DotFlow class. This my_callback function is only needed if you need to do something after the execution of the task, for example: sending a message to someone, making a phone call, or sending a letter. More details def my_callback(*args, **kwargs): print(args, kwargs) 3. Task function Now, create the function responsible for executing your task. It's very simple; just use the action decorator above the function, and that's it\u2014you've created a task. @action def my_task(): print(\"task\") 4. DotFlow Class Instantiate the DotFlow class in a workflow variable to be used in the following steps. More details . workflow = DotFlow() 5. Add Task Now, simply add the my_task and my_callback functions you created earlier to the workflow using the code below. This process is necessary to define which tasks will be executed and the order in which they will run. The execution order follows the sequence in which they were added to the workflow. More details workflow.task.add(step=my_task, callback=my_callback) 6. Start Finally, just execute the workflow with the following code snippet. More details workflow.start()","title":"Getting Started"},{"location":"nav/learn/getting-started/#getting-started","text":"February 10, 2025","title":"Getting Started"},{"location":"nav/learn/getting-started/#install","text":"To install Dotflow , run the following command from the command line:","title":"Install"},{"location":"nav/learn/getting-started/#with-pip","text":"pip install dotflow","title":"With Pip"},{"location":"nav/learn/getting-started/#with-poetry","text":"poetry add dotflow","title":"With Poetry"},{"location":"nav/learn/getting-started/#first-steps","text":"The simplest file could look like this: from dotflow import DotFlow, action def my_callback(*args, **kwargs): print(args, kwargs) @action def my_task(): print(\"task\") workflow = DotFlow() workflow.task.add(step=my_task, callback=my_callback) workflow.start()","title":"First Steps"},{"location":"nav/learn/getting-started/#1-import","text":"Start with the basics, which is importing the necessary classes and methods. ( DotFlow , action ) from dotflow import DotFlow, action","title":"1. Import"},{"location":"nav/learn/getting-started/#2-callback-function","text":"Create a my_callback function to receive execution information of a task. It is not necessary to include this function, as you will still have a report at the end of the execution in the instantiated object of the DotFlow class. This my_callback function is only needed if you need to do something after the execution of the task, for example: sending a message to someone, making a phone call, or sending a letter. More details def my_callback(*args, **kwargs): print(args, kwargs)","title":"2. Callback function"},{"location":"nav/learn/getting-started/#3-task-function","text":"Now, create the function responsible for executing your task. It's very simple; just use the action decorator above the function, and that's it\u2014you've created a task. @action def my_task(): print(\"task\")","title":"3. Task function"},{"location":"nav/learn/getting-started/#4-dotflow-class","text":"Instantiate the DotFlow class in a workflow variable to be used in the following steps. More details . workflow = DotFlow()","title":"4. DotFlow Class"},{"location":"nav/learn/getting-started/#5-add-task","text":"Now, simply add the my_task and my_callback functions you created earlier to the workflow using the code below. This process is necessary to define which tasks will be executed and the order in which they will run. The execution order follows the sequence in which they were added to the workflow. More details workflow.task.add(step=my_task, callback=my_callback)","title":"5. Add Task"},{"location":"nav/learn/getting-started/#6-start","text":"Finally, just execute the workflow with the following code snippet. More details workflow.start()","title":"6. Start"},{"location":"nav/learn/notify-with-telegram/","text":"Notify with Telegram May 4, 2025 Bot Telegram Create a bot on Telegram: 1 - Open the Telegram app on your mobile device. 2 - Tap the search icon and look for BotFather . 3 - Open the contact and type /newbot . 4 - Enter a name for your bot. Generate Bot Token: 1 - Type the command /token . 2 - Select the bot you just created from the list. 3 - BotFather will return an access token \u2014 copy and save this token securely. It will be required to authenticate your bot. Retrieving Your Telegram Chat ID 1 - Send a message to your bot in Telegram to ensure it appears in the bot's update log. 2 - Run the following curl command to fetch the latest updates from your bot: curl --location --globoff 'https://api.telegram.org/bot<YOUR_BOT_TOKEN>/getUpdates' Replace <YOUR_BOT_TOKEN> with the token provided by BotFather. 3 - Inspect the API response, and locate the following key result[0].channel_post.chat.id . This is your chat ID. 4 - Copy and store the chat ID in a secure location. You will need it to configure the NotifyTelegram instance. DotFlow Config Import Start with the basics, which is importing the necessary classes and methods. import os from dotflow import Config, DotFlow, action from dotflow.notify import NotifyTelegram from dotflow.types import TypeStatus Task function Use the @action decorator to define a simple task that will be executed in the workflow: @action def simple_task(): return \"ok\" Notify Class Instantiate the NotifyTelegram class with your Telegram bot credentials. You can use environment variables for security: notify = NotifyTelegram( token=os.getenv(\"TOKEN\"), chat_id=os.getenv(\"CHAT_ID\"), notification_type=TypeStatus.FAILED # Notify only on failure ) Dotflow Class Pass the notify instance into the Config class and initialize the DotFlow workflow: workflow = DotFlow( config=Config(notify=notify) ) Add Task Add your defined task as a step in the workflow: workflow.task.add(step=simple_task) Start Start the workflow execution: workflow.start()","title":"Notify with Telegram"},{"location":"nav/learn/notify-with-telegram/#notify-with-telegram","text":"May 4, 2025","title":"Notify with Telegram"},{"location":"nav/learn/notify-with-telegram/#bot-telegram","text":"","title":"Bot Telegram"},{"location":"nav/learn/notify-with-telegram/#create-a-bot-on-telegram","text":"1 - Open the Telegram app on your mobile device. 2 - Tap the search icon and look for BotFather . 3 - Open the contact and type /newbot . 4 - Enter a name for your bot.","title":"Create a bot on Telegram:"},{"location":"nav/learn/notify-with-telegram/#generate-bot-token","text":"1 - Type the command /token . 2 - Select the bot you just created from the list. 3 - BotFather will return an access token \u2014 copy and save this token securely. It will be required to authenticate your bot.","title":"Generate Bot Token:"},{"location":"nav/learn/notify-with-telegram/#retrieving-your-telegram-chat-id","text":"1 - Send a message to your bot in Telegram to ensure it appears in the bot's update log. 2 - Run the following curl command to fetch the latest updates from your bot: curl --location --globoff 'https://api.telegram.org/bot<YOUR_BOT_TOKEN>/getUpdates' Replace <YOUR_BOT_TOKEN> with the token provided by BotFather. 3 - Inspect the API response, and locate the following key result[0].channel_post.chat.id . This is your chat ID. 4 - Copy and store the chat ID in a secure location. You will need it to configure the NotifyTelegram instance.","title":"Retrieving Your Telegram Chat ID"},{"location":"nav/learn/notify-with-telegram/#dotflow-config","text":"","title":"DotFlow Config"},{"location":"nav/learn/notify-with-telegram/#import","text":"Start with the basics, which is importing the necessary classes and methods. import os from dotflow import Config, DotFlow, action from dotflow.notify import NotifyTelegram from dotflow.types import TypeStatus","title":"Import"},{"location":"nav/learn/notify-with-telegram/#task-function","text":"Use the @action decorator to define a simple task that will be executed in the workflow: @action def simple_task(): return \"ok\"","title":"Task function"},{"location":"nav/learn/notify-with-telegram/#notify-class","text":"Instantiate the NotifyTelegram class with your Telegram bot credentials. You can use environment variables for security: notify = NotifyTelegram( token=os.getenv(\"TOKEN\"), chat_id=os.getenv(\"CHAT_ID\"), notification_type=TypeStatus.FAILED # Notify only on failure )","title":"Notify Class"},{"location":"nav/learn/notify-with-telegram/#dotflow-class","text":"Pass the notify instance into the Config class and initialize the DotFlow workflow: workflow = DotFlow( config=Config(notify=notify) )","title":"Dotflow Class"},{"location":"nav/learn/notify-with-telegram/#add-task","text":"Add your defined task as a step in the workflow: workflow.task.add(step=simple_task)","title":"Add Task"},{"location":"nav/learn/notify-with-telegram/#start","text":"Start the workflow execution: workflow.start()","title":"Start"},{"location":"nav/reference/abc-flow/","text":"Flow dotflow.abc.flow.Flow Bases: ABC Source code in dotflow/abc/flow.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Flow ( ABC ): def __init__ ( self , tasks : List [ Task ], workflow_id : UUID , ignore : bool , groups : Dict [ str , List [ Task ]] ) -> None : self . queue = None self . tasks = tasks self . workflow_id = workflow_id self . ignore = ignore self . groups = groups self . setup_queue () self . run () @abstractmethod def setup_queue ( self ) -> None : self . queue = [] @abstractmethod def get_tasks ( self ) -> List [ Task ]: return self . queue @abstractmethod def _flow_callback ( self , task : Task ) -> None : self . queue . append ( task ) @abstractmethod def run ( self ) -> None : return None groups = groups instance-attribute ignore = ignore instance-attribute queue = None instance-attribute tasks = tasks instance-attribute workflow_id = workflow_id instance-attribute __init__ ( tasks , workflow_id , ignore , groups ) Source code in dotflow/abc/flow.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def __init__ ( self , tasks : List [ Task ], workflow_id : UUID , ignore : bool , groups : Dict [ str , List [ Task ]] ) -> None : self . queue = None self . tasks = tasks self . workflow_id = workflow_id self . ignore = ignore self . groups = groups self . setup_queue () self . run () get_tasks () abstractmethod Source code in dotflow/abc/flow.py 32 33 34 @abstractmethod def get_tasks ( self ) -> List [ Task ]: return self . queue run () abstractmethod Source code in dotflow/abc/flow.py 40 41 42 @abstractmethod def run ( self ) -> None : return None setup_queue () abstractmethod Source code in dotflow/abc/flow.py 28 29 30 @abstractmethod def setup_queue ( self ) -> None : self . queue = []","title":"Flow"},{"location":"nav/reference/abc-flow/#flow","text":"","title":"Flow"},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow","text":"Bases: ABC Source code in dotflow/abc/flow.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Flow ( ABC ): def __init__ ( self , tasks : List [ Task ], workflow_id : UUID , ignore : bool , groups : Dict [ str , List [ Task ]] ) -> None : self . queue = None self . tasks = tasks self . workflow_id = workflow_id self . ignore = ignore self . groups = groups self . setup_queue () self . run () @abstractmethod def setup_queue ( self ) -> None : self . queue = [] @abstractmethod def get_tasks ( self ) -> List [ Task ]: return self . queue @abstractmethod def _flow_callback ( self , task : Task ) -> None : self . queue . append ( task ) @abstractmethod def run ( self ) -> None : return None","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;Flow"},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.groups","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;groups"},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.ignore","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;ignore"},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.queue","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;queue"},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.tasks","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;tasks"},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.workflow_id","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;workflow_id"},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.__init__","text":"Source code in dotflow/abc/flow.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def __init__ ( self , tasks : List [ Task ], workflow_id : UUID , ignore : bool , groups : Dict [ str , List [ Task ]] ) -> None : self . queue = None self . tasks = tasks self . workflow_id = workflow_id self . ignore = ignore self . groups = groups self . setup_queue () self . run ()","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__init__"},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.get_tasks","text":"Source code in dotflow/abc/flow.py 32 33 34 @abstractmethod def get_tasks ( self ) -> List [ Task ]: return self . queue","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;get_tasks"},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.run","text":"Source code in dotflow/abc/flow.py 40 41 42 @abstractmethod def run ( self ) -> None : return None","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;run"},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.setup_queue","text":"Source code in dotflow/abc/flow.py 28 29 30 @abstractmethod def setup_queue ( self ) -> None : self . queue = []","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;setup_queue"},{"location":"nav/reference/abc-http/","text":"HTTPRequest dotflow.abc.http.HTTPRequest Bases: ABC Source code in dotflow/abc/http.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class HTTPRequest ( ABC ): def __init__ ( self , url : str , context : Callable ): self . url = url self . context = context @abstractmethod def request ( self , method : str , body : dict , params : dict , headers : dict , ) -> None : pass context = context instance-attribute url = url instance-attribute __init__ ( url , context ) Source code in dotflow/abc/http.py 9 10 11 def __init__ ( self , url : str , context : Callable ): self . url = url self . context = context request ( method , body , params , headers ) abstractmethod Source code in dotflow/abc/http.py 13 14 15 16 17 18 19 20 21 @abstractmethod def request ( self , method : str , body : dict , params : dict , headers : dict , ) -> None : pass","title":"HTTPRequest"},{"location":"nav/reference/abc-http/#httprequest","text":"","title":"HTTPRequest"},{"location":"nav/reference/abc-http/#dotflow.abc.http.HTTPRequest","text":"Bases: ABC Source code in dotflow/abc/http.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class HTTPRequest ( ABC ): def __init__ ( self , url : str , context : Callable ): self . url = url self . context = context @abstractmethod def request ( self , method : str , body : dict , params : dict , headers : dict , ) -> None : pass","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;HTTPRequest"},{"location":"nav/reference/abc-http/#dotflow.abc.http.HTTPRequest.context","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;context"},{"location":"nav/reference/abc-http/#dotflow.abc.http.HTTPRequest.url","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;url"},{"location":"nav/reference/abc-http/#dotflow.abc.http.HTTPRequest.__init__","text":"Source code in dotflow/abc/http.py 9 10 11 def __init__ ( self , url : str , context : Callable ): self . url = url self . context = context","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__init__"},{"location":"nav/reference/abc-http/#dotflow.abc.http.HTTPRequest.request","text":"Source code in dotflow/abc/http.py 13 14 15 16 17 18 19 20 21 @abstractmethod def request ( self , method : str , body : dict , params : dict , headers : dict , ) -> None : pass","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;request"},{"location":"nav/reference/abc-log/","text":"Log dotflow.abc.log.Log Bases: ABC Log Source code in dotflow/abc/log.py 8 9 10 11 12 13 14 15 16 17 class Log ( ABC ): \"\"\"Log\"\"\" @abstractmethod def info ( self , task : Any ) -> None : \"\"\"Info\"\"\" @abstractmethod def error ( self , task : Any ) -> None : \"\"\"Error\"\"\" error ( task ) abstractmethod Error Source code in dotflow/abc/log.py 15 16 17 @abstractmethod def error ( self , task : Any ) -> None : \"\"\"Error\"\"\" info ( task ) abstractmethod Info Source code in dotflow/abc/log.py 11 12 13 @abstractmethod def info ( self , task : Any ) -> None : \"\"\"Info\"\"\"","title":"Log"},{"location":"nav/reference/abc-log/#log","text":"","title":"Log"},{"location":"nav/reference/abc-log/#dotflow.abc.log.Log","text":"Bases: ABC Log Source code in dotflow/abc/log.py 8 9 10 11 12 13 14 15 16 17 class Log ( ABC ): \"\"\"Log\"\"\" @abstractmethod def info ( self , task : Any ) -> None : \"\"\"Info\"\"\" @abstractmethod def error ( self , task : Any ) -> None : \"\"\"Error\"\"\"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;Log"},{"location":"nav/reference/abc-log/#dotflow.abc.log.Log.error","text":"Error Source code in dotflow/abc/log.py 15 16 17 @abstractmethod def error ( self , task : Any ) -> None : \"\"\"Error\"\"\"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;error"},{"location":"nav/reference/abc-log/#dotflow.abc.log.Log.info","text":"Info Source code in dotflow/abc/log.py 11 12 13 @abstractmethod def info ( self , task : Any ) -> None : \"\"\"Info\"\"\"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;info"},{"location":"nav/reference/abc-notify/","text":"Notify dotflow.abc.notify.Notify Bases: ABC Notify Source code in dotflow/abc/notify.py 8 9 10 11 12 13 class Notify ( ABC ): \"\"\"Notify\"\"\" @abstractmethod def send ( self , task : Any ) -> None : \"\"\"Send\"\"\" send ( task ) abstractmethod Send Source code in dotflow/abc/notify.py 11 12 13 @abstractmethod def send ( self , task : Any ) -> None : \"\"\"Send\"\"\"","title":"Notify"},{"location":"nav/reference/abc-notify/#notify","text":"","title":"Notify"},{"location":"nav/reference/abc-notify/#dotflow.abc.notify.Notify","text":"Bases: ABC Notify Source code in dotflow/abc/notify.py 8 9 10 11 12 13 class Notify ( ABC ): \"\"\"Notify\"\"\" @abstractmethod def send ( self , task : Any ) -> None : \"\"\"Send\"\"\"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;Notify"},{"location":"nav/reference/abc-notify/#dotflow.abc.notify.Notify.send","text":"Send Source code in dotflow/abc/notify.py 11 12 13 @abstractmethod def send ( self , task : Any ) -> None : \"\"\"Send\"\"\"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;send"},{"location":"nav/reference/abc-storage/","text":"Storage dotflow.abc.storage.Storage Bases: ABC Storage Source code in dotflow/abc/storage.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Storage ( ABC ): \"\"\"Storage\"\"\" def __init__ ( self , * args , ** kwargs ): pass @abstractmethod def post ( self , key : str , context : Context ) -> None : \"\"\"Post context somewhere\"\"\" @abstractmethod def get ( self , key : str ) -> Context : \"\"\"Get context somewhere\"\"\" @abstractmethod def key ( self , task : Callable ): \"\"\"Function that returns a key to get and post storage\"\"\" __init__ ( * args , ** kwargs ) Source code in dotflow/abc/storage.py 12 13 def __init__ ( self , * args , ** kwargs ): pass get ( key ) abstractmethod Get context somewhere Source code in dotflow/abc/storage.py 19 20 21 @abstractmethod def get ( self , key : str ) -> Context : \"\"\"Get context somewhere\"\"\" key ( task ) abstractmethod Function that returns a key to get and post storage Source code in dotflow/abc/storage.py 23 24 25 @abstractmethod def key ( self , task : Callable ): \"\"\"Function that returns a key to get and post storage\"\"\" post ( key , context ) abstractmethod Post context somewhere Source code in dotflow/abc/storage.py 15 16 17 @abstractmethod def post ( self , key : str , context : Context ) -> None : \"\"\"Post context somewhere\"\"\"","title":"Storage"},{"location":"nav/reference/abc-storage/#storage","text":"","title":"Storage"},{"location":"nav/reference/abc-storage/#dotflow.abc.storage.Storage","text":"Bases: ABC Storage Source code in dotflow/abc/storage.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Storage ( ABC ): \"\"\"Storage\"\"\" def __init__ ( self , * args , ** kwargs ): pass @abstractmethod def post ( self , key : str , context : Context ) -> None : \"\"\"Post context somewhere\"\"\" @abstractmethod def get ( self , key : str ) -> Context : \"\"\"Get context somewhere\"\"\" @abstractmethod def key ( self , task : Callable ): \"\"\"Function that returns a key to get and post storage\"\"\"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;Storage"},{"location":"nav/reference/abc-storage/#dotflow.abc.storage.Storage.__init__","text":"Source code in dotflow/abc/storage.py 12 13 def __init__ ( self , * args , ** kwargs ): pass","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__init__"},{"location":"nav/reference/abc-storage/#dotflow.abc.storage.Storage.get","text":"Get context somewhere Source code in dotflow/abc/storage.py 19 20 21 @abstractmethod def get ( self , key : str ) -> Context : \"\"\"Get context somewhere\"\"\"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;get"},{"location":"nav/reference/abc-storage/#dotflow.abc.storage.Storage.key","text":"Function that returns a key to get and post storage Source code in dotflow/abc/storage.py 23 24 25 @abstractmethod def key ( self , task : Callable ): \"\"\"Function that returns a key to get and post storage\"\"\"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;key"},{"location":"nav/reference/abc-storage/#dotflow.abc.storage.Storage.post","text":"Post context somewhere Source code in dotflow/abc/storage.py 15 16 17 @abstractmethod def post ( self , key : str , context : Context ) -> None : \"\"\"Post context somewhere\"\"\"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;post"},{"location":"nav/reference/abc-tcp/","text":"TCP dotflow.abc.tcp.TCPClient Bases: ABC Source code in dotflow/abc/tcp.py 7 8 9 10 11 12 13 14 15 class TCPClient ( ABC ): def __init__ ( self , url : str ): self . url = url self . context = None @abstractmethod def sender ( self , content : dict ) -> None : pass context = None instance-attribute url = url instance-attribute __init__ ( url ) Source code in dotflow/abc/tcp.py 9 10 11 def __init__ ( self , url : str ): self . url = url self . context = None sender ( content ) abstractmethod Source code in dotflow/abc/tcp.py 13 14 15 @abstractmethod def sender ( self , content : dict ) -> None : pass dotflow.abc.tcp.TCPServer Bases: ABC Source code in dotflow/abc/tcp.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class TCPServer ( ABC ): def __init__ ( self , url : str , handler : Callable ): self . url = url self . handler = handler self . context = None @abstractmethod async def receiver ( self ) -> None : pass @abstractmethod async def run ( self ) -> None : pass context = None instance-attribute handler = handler instance-attribute url = url instance-attribute __init__ ( url , handler ) Source code in dotflow/abc/tcp.py 20 21 22 23 def __init__ ( self , url : str , handler : Callable ): self . url = url self . handler = handler self . context = None receiver () abstractmethod async Source code in dotflow/abc/tcp.py 25 26 27 @abstractmethod async def receiver ( self ) -> None : pass run () abstractmethod async Source code in dotflow/abc/tcp.py 29 30 31 @abstractmethod async def run ( self ) -> None : pass","title":"TCP"},{"location":"nav/reference/abc-tcp/#tcp","text":"","title":"TCP"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPClient","text":"Bases: ABC Source code in dotflow/abc/tcp.py 7 8 9 10 11 12 13 14 15 class TCPClient ( ABC ): def __init__ ( self , url : str ): self . url = url self . context = None @abstractmethod def sender ( self , content : dict ) -> None : pass","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;TCPClient"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPClient.context","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;context"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPClient.url","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;url"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPClient.__init__","text":"Source code in dotflow/abc/tcp.py 9 10 11 def __init__ ( self , url : str ): self . url = url self . context = None","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__init__"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPClient.sender","text":"Source code in dotflow/abc/tcp.py 13 14 15 @abstractmethod def sender ( self , content : dict ) -> None : pass","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;sender"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPServer","text":"Bases: ABC Source code in dotflow/abc/tcp.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class TCPServer ( ABC ): def __init__ ( self , url : str , handler : Callable ): self . url = url self . handler = handler self . context = None @abstractmethod async def receiver ( self ) -> None : pass @abstractmethod async def run ( self ) -> None : pass","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;TCPServer"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPServer.context","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;context"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPServer.handler","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;handler"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPServer.url","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;url"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPServer.__init__","text":"Source code in dotflow/abc/tcp.py 20 21 22 23 def __init__ ( self , url : str , handler : Callable ): self . url = url self . handler = handler self . context = None","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__init__"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPServer.receiver","text":"Source code in dotflow/abc/tcp.py 25 26 27 @abstractmethod async def receiver ( self ) -> None : pass","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;receiver"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPServer.run","text":"Source code in dotflow/abc/tcp.py 29 30 31 @abstractmethod async def run ( self ) -> None : pass","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;run"},{"location":"nav/reference/action/","text":"Action dotflow.core.action.Action Bases: object Import You can import the action decorator directly from dotflow: from dotflow import action Example class dotflow.core.action.Action Standard @action def my_task(): print(\"task\") With Retry @action(retry=5) def my_task(): print(\"task\") With Timeout @action(timeout=60) def my_task(): print(\"task\") With Retry delay @action(retry=5, retry_delay=5) def my_task(): print(\"task\") With Backoff @action(retry=5, backoff=True) def my_task(): print(\"task\") Parameters: Name Type Description Default func Callable None task Callable None retry int Number of task retries on on_failure. 1 timeout int Execution timeout for a task. Duration (in seconds) 0 retry_delay int Retry delay on task on_failure. Duration (in seconds) 1 backoff int Exponential backoff False Source code in dotflow/core/action.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 class Action ( object ): \"\"\" Import: You can import the **action** decorator directly from dotflow: from dotflow import action Example: `class` dotflow.core.action.Action Standard @action def my_task(): print(\"task\") With Retry @action(retry=5) def my_task(): print(\"task\") With Timeout @action(timeout=60) def my_task(): print(\"task\") With Retry delay @action(retry=5, retry_delay=5) def my_task(): print(\"task\") With Backoff @action(retry=5, backoff=True) def my_task(): print(\"task\") Args: func (Callable): task (Callable): retry (int): Number of task retries on on_failure. timeout (int): Execution timeout for a task. Duration (in seconds) retry_delay (int): Retry delay on task on_failure. Duration (in seconds) backoff (int): Exponential backoff \"\"\" def __init__ ( self , func : Callable = None , task : Callable = None , retry : int = 1 , timeout : int = 0 , retry_delay : int = 1 , backoff : bool = False , ) -> None : self . func = func self . task = task self . retry = retry self . timeout = timeout self . retry_delay = retry_delay self . backoff = backoff self . params = [] def __call__ ( self , * args , ** kwargs ): # With parameters if self . func : self . _set_params () task = self . _get_task ( kwargs = kwargs ) contexts = self . _get_context ( kwargs = kwargs ) if contexts : return Context ( storage = self . _run_action ( * args , ** contexts ), task_id = task . task_id , workflow_id = task . workflow_id , ) return Context ( storage = self . _run_action ( * args ), task_id = task . task_id , workflow_id = task . workflow_id , ) # No parameters def action ( * _args , ** _kwargs ): self . func = args [ 0 ] self . _set_params () task = self . _get_task ( kwargs = _kwargs ) contexts = self . _get_context ( kwargs = _kwargs ) if contexts : return Context ( storage = self . _run_action ( * _args , ** contexts ), task_id = task . task_id , workflow_id = task . workflow_id , ) return Context ( storage = self . _run_action ( * _args ), task_id = task . task_id , workflow_id = task . workflow_id , ) return action def _run_action ( self , * args , ** kwargs ): for attempt in range ( 1 , self . retry + 1 ): try : if self . timeout : with ThreadPoolExecutor ( max_workers = 1 ) as executor : future = executor . submit ( self . func , * args , ** kwargs ) return future . result ( timeout = self . timeout ) return self . func ( * args , ** kwargs ) except Exception as error : last_exception = error if is_execution_with_class_internal_error ( error = last_exception ): raise ExecutionWithClassError () if attempt == self . retry : raise last_exception sleep ( self . retry_delay ) if self . backoff : self . retry_delay *= 2 def _set_params ( self ): if isinstance ( self . func , FunctionType ): self . params = [ param for param in self . func . __code__ . co_varnames ] if type ( self . func ) is type : if hasattr ( self . func , \"__init__\" ): if hasattr ( self . func . __init__ , \"__code__\" ): self . params = [ param for param in self . func . __init__ . __code__ . co_varnames ] def _get_context ( self , kwargs : Dict ): context = {} if \"initial_context\" in self . params : context [ \"initial_context\" ] = Context ( kwargs . get ( \"initial_context\" )) if \"previous_context\" in self . params : context [ \"previous_context\" ] = Context ( kwargs . get ( \"previous_context\" )) return context def _get_task ( self , kwargs : Dict ): return kwargs . get ( \"task\" ) func = func instance-attribute task = task instance-attribute retry = retry instance-attribute timeout = timeout instance-attribute retry_delay = retry_delay instance-attribute backoff = backoff instance-attribute params = [] instance-attribute _run_action ( * args , ** kwargs ) Source code in dotflow/core/action.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def _run_action ( self , * args , ** kwargs ): for attempt in range ( 1 , self . retry + 1 ): try : if self . timeout : with ThreadPoolExecutor ( max_workers = 1 ) as executor : future = executor . submit ( self . func , * args , ** kwargs ) return future . result ( timeout = self . timeout ) return self . func ( * args , ** kwargs ) except Exception as error : last_exception = error if is_execution_with_class_internal_error ( error = last_exception ): raise ExecutionWithClassError () if attempt == self . retry : raise last_exception sleep ( self . retry_delay ) if self . backoff : self . retry_delay *= 2 _set_params () Source code in dotflow/core/action.py 163 164 165 166 167 168 169 170 171 172 def _set_params ( self ): if isinstance ( self . func , FunctionType ): self . params = [ param for param in self . func . __code__ . co_varnames ] if type ( self . func ) is type : if hasattr ( self . func , \"__init__\" ): if hasattr ( self . func . __init__ , \"__code__\" ): self . params = [ param for param in self . func . __init__ . __code__ . co_varnames ] _get_context ( kwargs ) Source code in dotflow/core/action.py 174 175 176 177 178 179 180 181 182 def _get_context ( self , kwargs : Dict ): context = {} if \"initial_context\" in self . params : context [ \"initial_context\" ] = Context ( kwargs . get ( \"initial_context\" )) if \"previous_context\" in self . params : context [ \"previous_context\" ] = Context ( kwargs . get ( \"previous_context\" )) return context _get_task ( kwargs ) Source code in dotflow/core/action.py 184 185 def _get_task ( self , kwargs : Dict ): return kwargs . get ( \"task\" )","title":"Action"},{"location":"nav/reference/action/#action","text":"","title":"Action"},{"location":"nav/reference/action/#dotflow.core.action.Action","text":"Bases: object Import You can import the action decorator directly from dotflow: from dotflow import action Example class dotflow.core.action.Action Standard @action def my_task(): print(\"task\") With Retry @action(retry=5) def my_task(): print(\"task\") With Timeout @action(timeout=60) def my_task(): print(\"task\") With Retry delay @action(retry=5, retry_delay=5) def my_task(): print(\"task\") With Backoff @action(retry=5, backoff=True) def my_task(): print(\"task\") Parameters: Name Type Description Default func Callable None task Callable None retry int Number of task retries on on_failure. 1 timeout int Execution timeout for a task. Duration (in seconds) 0 retry_delay int Retry delay on task on_failure. Duration (in seconds) 1 backoff int Exponential backoff False Source code in dotflow/core/action.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 class Action ( object ): \"\"\" Import: You can import the **action** decorator directly from dotflow: from dotflow import action Example: `class` dotflow.core.action.Action Standard @action def my_task(): print(\"task\") With Retry @action(retry=5) def my_task(): print(\"task\") With Timeout @action(timeout=60) def my_task(): print(\"task\") With Retry delay @action(retry=5, retry_delay=5) def my_task(): print(\"task\") With Backoff @action(retry=5, backoff=True) def my_task(): print(\"task\") Args: func (Callable): task (Callable): retry (int): Number of task retries on on_failure. timeout (int): Execution timeout for a task. Duration (in seconds) retry_delay (int): Retry delay on task on_failure. Duration (in seconds) backoff (int): Exponential backoff \"\"\" def __init__ ( self , func : Callable = None , task : Callable = None , retry : int = 1 , timeout : int = 0 , retry_delay : int = 1 , backoff : bool = False , ) -> None : self . func = func self . task = task self . retry = retry self . timeout = timeout self . retry_delay = retry_delay self . backoff = backoff self . params = [] def __call__ ( self , * args , ** kwargs ): # With parameters if self . func : self . _set_params () task = self . _get_task ( kwargs = kwargs ) contexts = self . _get_context ( kwargs = kwargs ) if contexts : return Context ( storage = self . _run_action ( * args , ** contexts ), task_id = task . task_id , workflow_id = task . workflow_id , ) return Context ( storage = self . _run_action ( * args ), task_id = task . task_id , workflow_id = task . workflow_id , ) # No parameters def action ( * _args , ** _kwargs ): self . func = args [ 0 ] self . _set_params () task = self . _get_task ( kwargs = _kwargs ) contexts = self . _get_context ( kwargs = _kwargs ) if contexts : return Context ( storage = self . _run_action ( * _args , ** contexts ), task_id = task . task_id , workflow_id = task . workflow_id , ) return Context ( storage = self . _run_action ( * _args ), task_id = task . task_id , workflow_id = task . workflow_id , ) return action def _run_action ( self , * args , ** kwargs ): for attempt in range ( 1 , self . retry + 1 ): try : if self . timeout : with ThreadPoolExecutor ( max_workers = 1 ) as executor : future = executor . submit ( self . func , * args , ** kwargs ) return future . result ( timeout = self . timeout ) return self . func ( * args , ** kwargs ) except Exception as error : last_exception = error if is_execution_with_class_internal_error ( error = last_exception ): raise ExecutionWithClassError () if attempt == self . retry : raise last_exception sleep ( self . retry_delay ) if self . backoff : self . retry_delay *= 2 def _set_params ( self ): if isinstance ( self . func , FunctionType ): self . params = [ param for param in self . func . __code__ . co_varnames ] if type ( self . func ) is type : if hasattr ( self . func , \"__init__\" ): if hasattr ( self . func . __init__ , \"__code__\" ): self . params = [ param for param in self . func . __init__ . __code__ . co_varnames ] def _get_context ( self , kwargs : Dict ): context = {} if \"initial_context\" in self . params : context [ \"initial_context\" ] = Context ( kwargs . get ( \"initial_context\" )) if \"previous_context\" in self . params : context [ \"previous_context\" ] = Context ( kwargs . get ( \"previous_context\" )) return context def _get_task ( self , kwargs : Dict ): return kwargs . get ( \"task\" )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;Action"},{"location":"nav/reference/action/#dotflow.core.action.Action.func","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;func"},{"location":"nav/reference/action/#dotflow.core.action.Action.task","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;task"},{"location":"nav/reference/action/#dotflow.core.action.Action.retry","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;retry"},{"location":"nav/reference/action/#dotflow.core.action.Action.timeout","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;timeout"},{"location":"nav/reference/action/#dotflow.core.action.Action.retry_delay","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;retry_delay"},{"location":"nav/reference/action/#dotflow.core.action.Action.backoff","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;backoff"},{"location":"nav/reference/action/#dotflow.core.action.Action.params","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;params"},{"location":"nav/reference/action/#dotflow.core.action.Action._run_action","text":"Source code in dotflow/core/action.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def _run_action ( self , * args , ** kwargs ): for attempt in range ( 1 , self . retry + 1 ): try : if self . timeout : with ThreadPoolExecutor ( max_workers = 1 ) as executor : future = executor . submit ( self . func , * args , ** kwargs ) return future . result ( timeout = self . timeout ) return self . func ( * args , ** kwargs ) except Exception as error : last_exception = error if is_execution_with_class_internal_error ( error = last_exception ): raise ExecutionWithClassError () if attempt == self . retry : raise last_exception sleep ( self . retry_delay ) if self . backoff : self . retry_delay *= 2","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;_run_action"},{"location":"nav/reference/action/#dotflow.core.action.Action._set_params","text":"Source code in dotflow/core/action.py 163 164 165 166 167 168 169 170 171 172 def _set_params ( self ): if isinstance ( self . func , FunctionType ): self . params = [ param for param in self . func . __code__ . co_varnames ] if type ( self . func ) is type : if hasattr ( self . func , \"__init__\" ): if hasattr ( self . func . __init__ , \"__code__\" ): self . params = [ param for param in self . func . __init__ . __code__ . co_varnames ]","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;_set_params"},{"location":"nav/reference/action/#dotflow.core.action.Action._get_context","text":"Source code in dotflow/core/action.py 174 175 176 177 178 179 180 181 182 def _get_context ( self , kwargs : Dict ): context = {} if \"initial_context\" in self . params : context [ \"initial_context\" ] = Context ( kwargs . get ( \"initial_context\" )) if \"previous_context\" in self . params : context [ \"previous_context\" ] = Context ( kwargs . get ( \"previous_context\" )) return context","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;_get_context"},{"location":"nav/reference/action/#dotflow.core.action.Action._get_task","text":"Source code in dotflow/core/action.py 184 185 def _get_task ( self , kwargs : Dict ): return kwargs . get ( \"task\" )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;_get_task"},{"location":"nav/reference/config/","text":"Config dotflow.core.config.Config Import You can import the Config class with: from dotflow import Config from dotflow.providers import ( StorageDefault, NotifyDefault, LogDefault ) Example class dotflow.core.config.Config config = Config( storage=StorageFile(path=\".output\"), notify=NotifyDefault(), log=LogDefault() ) Parameters: Name Type Description Default storage Optional [ Storage ] Type of the storage. StorageDefault () notify Optional [ Notify ] Type of the notify. NotifyDefault () log Optional [ Log ] Type of the notify. LogDefault () Attributes: Name Type Description storage Optional [ Storage ] notify Optional [ Notify ] log Optional [ Log ] Source code in dotflow/core/config.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Config : \"\"\" Import: You can import the **Config** class with: from dotflow import Config from dotflow.providers import ( StorageDefault, NotifyDefault, LogDefault ) Example: `class` dotflow.core.config.Config config = Config( storage=StorageFile(path=\".output\"), notify=NotifyDefault(), log=LogDefault() ) Args: storage (Optional[Storage]): Type of the storage. notify (Optional[Notify]): Type of the notify. log (Optional[Log]): Type of the notify. Attributes: storage (Optional[Storage]): notify (Optional[Notify]): log (Optional[Log]): \"\"\" def __init__ ( self , storage : Optional [ Storage ] = StorageDefault (), notify : Optional [ Notify ] = NotifyDefault (), log : Optional [ Log ] = LogDefault (), ) -> None : self . storage = storage self . notify = notify self . log = log","title":"Config"},{"location":"nav/reference/config/#config","text":"","title":"Config"},{"location":"nav/reference/config/#dotflow.core.config.Config","text":"Import You can import the Config class with: from dotflow import Config from dotflow.providers import ( StorageDefault, NotifyDefault, LogDefault ) Example class dotflow.core.config.Config config = Config( storage=StorageFile(path=\".output\"), notify=NotifyDefault(), log=LogDefault() ) Parameters: Name Type Description Default storage Optional [ Storage ] Type of the storage. StorageDefault () notify Optional [ Notify ] Type of the notify. NotifyDefault () log Optional [ Log ] Type of the notify. LogDefault () Attributes: Name Type Description storage Optional [ Storage ] notify Optional [ Notify ] log Optional [ Log ] Source code in dotflow/core/config.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Config : \"\"\" Import: You can import the **Config** class with: from dotflow import Config from dotflow.providers import ( StorageDefault, NotifyDefault, LogDefault ) Example: `class` dotflow.core.config.Config config = Config( storage=StorageFile(path=\".output\"), notify=NotifyDefault(), log=LogDefault() ) Args: storage (Optional[Storage]): Type of the storage. notify (Optional[Notify]): Type of the notify. log (Optional[Log]): Type of the notify. Attributes: storage (Optional[Storage]): notify (Optional[Notify]): log (Optional[Log]): \"\"\" def __init__ ( self , storage : Optional [ Storage ] = StorageDefault (), notify : Optional [ Notify ] = NotifyDefault (), log : Optional [ Log ] = LogDefault (), ) -> None : self . storage = storage self . notify = notify self . log = log","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;Config"},{"location":"nav/reference/context-instance/","text":"ContextInstance dotflow.core.context.ContextInstance Import You can import the ContextInstance class with: from dotflow.core.context import ContextInstance Source code in dotflow/core/context.py 9 10 11 12 13 14 15 16 17 18 19 20 21 class ContextInstance : \"\"\" Import: You can import the **ContextInstance** class with: from dotflow.core.context import ContextInstance \"\"\" def __init__ ( self , * args , ** kwargs ): self . _time = None self . _task_id = None self . _workflow_id = None self . _storage = None _time = None instance-attribute _task_id = None instance-attribute _workflow_id = None instance-attribute _storage = None instance-attribute","title":"ContextInstance"},{"location":"nav/reference/context-instance/#contextinstance","text":"","title":"ContextInstance"},{"location":"nav/reference/context-instance/#dotflow.core.context.ContextInstance","text":"Import You can import the ContextInstance class with: from dotflow.core.context import ContextInstance Source code in dotflow/core/context.py 9 10 11 12 13 14 15 16 17 18 19 20 21 class ContextInstance : \"\"\" Import: You can import the **ContextInstance** class with: from dotflow.core.context import ContextInstance \"\"\" def __init__ ( self , * args , ** kwargs ): self . _time = None self . _task_id = None self . _workflow_id = None self . _storage = None","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;ContextInstance"},{"location":"nav/reference/context-instance/#dotflow.core.context.ContextInstance._time","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;_time"},{"location":"nav/reference/context-instance/#dotflow.core.context.ContextInstance._task_id","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;_task_id"},{"location":"nav/reference/context-instance/#dotflow.core.context.ContextInstance._workflow_id","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;_workflow_id"},{"location":"nav/reference/context-instance/#dotflow.core.context.ContextInstance._storage","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;_storage"},{"location":"nav/reference/context/","text":"Context dotflow.core.context.Context Bases: ContextInstance Import You can import the Context class directly from dotflow: from dotflow import Context Example class dotflow.core.context.Context Context( storage={\"data\": [0, 1, 2, 3]} ) Parameters: Name Type Description Default storage Any Attribute where any type of Python object can be stored. None task_id int Task ID. 0 workflow_id UUID Workflow ID. None Source code in dotflow/core/context.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class Context ( ContextInstance ): \"\"\" Import: You can import the Context class directly from dotflow: from dotflow import Context Example: `class` dotflow.core.context.Context Context( storage={\"data\": [0, 1, 2, 3]} ) Args: storage (Any): Attribute where any type of Python object can be stored. task_id (int): Task ID. workflow_id (UUID): Workflow ID. \"\"\" def __init__ ( self , storage : Any = None , task_id : int = 0 , workflow_id : UUID = None , ) -> None : super () . __init__ ( task_id , storage , task_id , workflow_id ) self . time = datetime . now () self . task_id = task_id self . workflow_id = workflow_id self . storage = storage @property def time ( self ): return self . _time @time . setter def time ( self , value : datetime ): self . _time = value @property def task_id ( self ): return self . _task_id @task_id . setter def task_id ( self , value : int ): if isinstance ( value , int ): self . _task_id = value if not self . task_id : self . _task_id = value @property def workflow_id ( self ): return self . _workflow_id @workflow_id . setter def workflow_id ( self , value : UUID ): if isinstance ( value , UUID ): self . _workflow_id = value @property def storage ( self ): return self . _storage @storage . setter def storage ( self , value : Any ): if isinstance ( value , Context ): self . _storage = value . storage self . time = value . time self . task_id = value . task_id self . workflow_id = value . workflow_id else : self . _storage = value time property writable task_id property writable workflow_id property writable storage property writable","title":"Context"},{"location":"nav/reference/context/#context","text":"","title":"Context"},{"location":"nav/reference/context/#dotflow.core.context.Context","text":"Bases: ContextInstance Import You can import the Context class directly from dotflow: from dotflow import Context Example class dotflow.core.context.Context Context( storage={\"data\": [0, 1, 2, 3]} ) Parameters: Name Type Description Default storage Any Attribute where any type of Python object can be stored. None task_id int Task ID. 0 workflow_id UUID Workflow ID. None Source code in dotflow/core/context.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class Context ( ContextInstance ): \"\"\" Import: You can import the Context class directly from dotflow: from dotflow import Context Example: `class` dotflow.core.context.Context Context( storage={\"data\": [0, 1, 2, 3]} ) Args: storage (Any): Attribute where any type of Python object can be stored. task_id (int): Task ID. workflow_id (UUID): Workflow ID. \"\"\" def __init__ ( self , storage : Any = None , task_id : int = 0 , workflow_id : UUID = None , ) -> None : super () . __init__ ( task_id , storage , task_id , workflow_id ) self . time = datetime . now () self . task_id = task_id self . workflow_id = workflow_id self . storage = storage @property def time ( self ): return self . _time @time . setter def time ( self , value : datetime ): self . _time = value @property def task_id ( self ): return self . _task_id @task_id . setter def task_id ( self , value : int ): if isinstance ( value , int ): self . _task_id = value if not self . task_id : self . _task_id = value @property def workflow_id ( self ): return self . _workflow_id @workflow_id . setter def workflow_id ( self , value : UUID ): if isinstance ( value , UUID ): self . _workflow_id = value @property def storage ( self ): return self . _storage @storage . setter def storage ( self , value : Any ): if isinstance ( value , Context ): self . _storage = value . storage self . time = value . time self . task_id = value . task_id self . workflow_id = value . workflow_id else : self . _storage = value","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;Context"},{"location":"nav/reference/context/#dotflow.core.context.Context.time","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;time"},{"location":"nav/reference/context/#dotflow.core.context.Context.task_id","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;task_id"},{"location":"nav/reference/context/#dotflow.core.context.Context.workflow_id","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;workflow_id"},{"location":"nav/reference/context/#dotflow.core.context.Context.storage","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;storage"},{"location":"nav/reference/decorators/","text":"Decorators dotflow . core . decorators . time . time ( func ) \"Time Decorator Source code in dotflow/core/decorators/time.py 6 7 8 9 10 11 12 13 def time ( func ): \"\"\"\"Time Decorator\"\"\" def inside ( * args , ** kwargs ): start = datetime . now () task = func ( * args , ** kwargs ) task . duration = ( datetime . now () - start ) . total_seconds () return task return inside","title":"Decorators"},{"location":"nav/reference/decorators/#decorators","text":"","title":"Decorators"},{"location":"nav/reference/decorators/#dotflow.core.decorators.time.time","text":"\"Time Decorator Source code in dotflow/core/decorators/time.py 6 7 8 9 10 11 12 13 def time ( func ): \"\"\"\"Time Decorator\"\"\" def inside ( * args , ** kwargs ): start = datetime . now () task = func ( * args , ** kwargs ) task . duration = ( datetime . now () - start ) . total_seconds () return task return inside","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-function\"></code>&nbsp;time"},{"location":"nav/reference/dotflow/","text":"DotFlow dotflow.core.dotflow.DotFlow Import You can import the Dotflow class directly from dotflow: from dotflow import DotFlow, Config from dotflow.providers import StorageFile Example class dotflow.core.dotflow.Dotflow config = Config( storage=StorageFile() ) workflow = DotFlow(config=config) Parameters: Name Type Description Default config Optional [ Config ] Configuration class. None Attributes: Name Type Description workflow_id UUID task List [ Task ] start Manager Source code in dotflow/core/dotflow.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class DotFlow : \"\"\" Import: You can import the **Dotflow** class directly from dotflow: from dotflow import DotFlow, Config from dotflow.providers import StorageFile Example: `class` dotflow.core.dotflow.Dotflow config = Config( storage=StorageFile() ) workflow = DotFlow(config=config) Args: config (Optional[Config]): Configuration class. Attributes: workflow_id (UUID): task (List[Task]): start (Manager): \"\"\" def __init__ ( self , config : Optional [ Config ] = None ) -> None : self . workflow_id = uuid4 () config = config if config else Config () self . task = TaskBuilder ( config = config , workflow_id = self . workflow_id ) self . start = partial ( Manager , tasks = self . task . queue , workflow_id = self . workflow_id ) def result_task ( self ): \"\"\" Returns: list (List[Task]): Returns a list of Task class. \"\"\" return self . task . queue def result_context ( self ): \"\"\" Returns: list (List[Context]): Returns a list of Context class. \"\"\" return [ task . current_context for task in self . task . queue ] def result_storage ( self ): \"\"\" Returns: list (List[Any]): Returns a list of assorted objects. \"\"\" return [ task . current_context . storage for task in self . task . queue ] def result ( self ): return self . task . result () workflow_id = uuid4 () instance-attribute task = TaskBuilder ( config = config , workflow_id = self . workflow_id ) instance-attribute start = partial ( Manager , tasks = self . task . queue , workflow_id = self . workflow_id ) instance-attribute result_task () Returns: Name Type Description list List [ Task ] Returns a list of Task class. Source code in dotflow/core/dotflow.py 58 59 60 61 62 63 def result_task ( self ): \"\"\" Returns: list (List[Task]): Returns a list of Task class. \"\"\" return self . task . queue result_context () Returns: Name Type Description list List [ Context ] Returns a list of Context class. Source code in dotflow/core/dotflow.py 65 66 67 68 69 70 def result_context ( self ): \"\"\" Returns: list (List[Context]): Returns a list of Context class. \"\"\" return [ task . current_context for task in self . task . queue ] result_storage () Returns: Name Type Description list List [ Any ] Returns a list of assorted objects. Source code in dotflow/core/dotflow.py 72 73 74 75 76 77 def result_storage ( self ): \"\"\" Returns: list (List[Any]): Returns a list of assorted objects. \"\"\" return [ task . current_context . storage for task in self . task . queue ]","title":"DotFlow"},{"location":"nav/reference/dotflow/#dotflow","text":"","title":"DotFlow"},{"location":"nav/reference/dotflow/#dotflow.core.dotflow.DotFlow","text":"Import You can import the Dotflow class directly from dotflow: from dotflow import DotFlow, Config from dotflow.providers import StorageFile Example class dotflow.core.dotflow.Dotflow config = Config( storage=StorageFile() ) workflow = DotFlow(config=config) Parameters: Name Type Description Default config Optional [ Config ] Configuration class. None Attributes: Name Type Description workflow_id UUID task List [ Task ] start Manager Source code in dotflow/core/dotflow.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class DotFlow : \"\"\" Import: You can import the **Dotflow** class directly from dotflow: from dotflow import DotFlow, Config from dotflow.providers import StorageFile Example: `class` dotflow.core.dotflow.Dotflow config = Config( storage=StorageFile() ) workflow = DotFlow(config=config) Args: config (Optional[Config]): Configuration class. Attributes: workflow_id (UUID): task (List[Task]): start (Manager): \"\"\" def __init__ ( self , config : Optional [ Config ] = None ) -> None : self . workflow_id = uuid4 () config = config if config else Config () self . task = TaskBuilder ( config = config , workflow_id = self . workflow_id ) self . start = partial ( Manager , tasks = self . task . queue , workflow_id = self . workflow_id ) def result_task ( self ): \"\"\" Returns: list (List[Task]): Returns a list of Task class. \"\"\" return self . task . queue def result_context ( self ): \"\"\" Returns: list (List[Context]): Returns a list of Context class. \"\"\" return [ task . current_context for task in self . task . queue ] def result_storage ( self ): \"\"\" Returns: list (List[Any]): Returns a list of assorted objects. \"\"\" return [ task . current_context . storage for task in self . task . queue ] def result ( self ): return self . task . result ()","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;DotFlow"},{"location":"nav/reference/dotflow/#dotflow.core.dotflow.DotFlow.workflow_id","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;workflow_id"},{"location":"nav/reference/dotflow/#dotflow.core.dotflow.DotFlow.task","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;task"},{"location":"nav/reference/dotflow/#dotflow.core.dotflow.DotFlow.start","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;start"},{"location":"nav/reference/dotflow/#dotflow.core.dotflow.DotFlow.result_task","text":"Returns: Name Type Description list List [ Task ] Returns a list of Task class. Source code in dotflow/core/dotflow.py 58 59 60 61 62 63 def result_task ( self ): \"\"\" Returns: list (List[Task]): Returns a list of Task class. \"\"\" return self . task . queue","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;result_task"},{"location":"nav/reference/dotflow/#dotflow.core.dotflow.DotFlow.result_context","text":"Returns: Name Type Description list List [ Context ] Returns a list of Context class. Source code in dotflow/core/dotflow.py 65 66 67 68 69 70 def result_context ( self ): \"\"\" Returns: list (List[Context]): Returns a list of Context class. \"\"\" return [ task . current_context for task in self . task . queue ]","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;result_context"},{"location":"nav/reference/dotflow/#dotflow.core.dotflow.DotFlow.result_storage","text":"Returns: Name Type Description list List [ Any ] Returns a list of assorted objects. Source code in dotflow/core/dotflow.py 72 73 74 75 76 77 def result_storage ( self ): \"\"\" Returns: list (List[Any]): Returns a list of assorted objects. \"\"\" return [ task . current_context . storage for task in self . task . queue ]","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;result_storage"},{"location":"nav/reference/exception/","text":"Exception dotflow.core.exception.MissingActionDecorator Bases: Exception Source code in dotflow/core/exception.py 11 12 13 14 15 16 class MissingActionDecorator ( Exception ): def __init__ ( self ): super ( MissingActionDecorator , self ) . __init__ ( MESSAGE_MISSING_STEP_DECORATOR ) __init__ () Source code in dotflow/core/exception.py 13 14 15 16 def __init__ ( self ): super ( MissingActionDecorator , self ) . __init__ ( MESSAGE_MISSING_STEP_DECORATOR ) dotflow.core.exception.ExecutionModeNotExist Bases: Exception Source code in dotflow/core/exception.py 19 20 21 22 23 24 class ExecutionModeNotExist ( Exception ): def __init__ ( self ): super ( ExecutionModeNotExist , self ) . __init__ ( MESSAGE_EXECUTION_NOT_EXIST ) __init__ () Source code in dotflow/core/exception.py 21 22 23 24 def __init__ ( self ): super ( ExecutionModeNotExist , self ) . __init__ ( MESSAGE_EXECUTION_NOT_EXIST ) dotflow.core.exception.ImportModuleError Bases: Exception Source code in dotflow/core/exception.py 27 28 29 30 31 32 33 34 class ImportModuleError ( Exception ): def __init__ ( self , module : str ): super ( ImportModuleError , self ) . __init__ ( MESSAGE_IMPORT_MODULE_ERROR . format ( module = module ) ) __init__ ( module ) Source code in dotflow/core/exception.py 29 30 31 32 33 34 def __init__ ( self , module : str ): super ( ImportModuleError , self ) . __init__ ( MESSAGE_IMPORT_MODULE_ERROR . format ( module = module ) ) dotflow.core.exception.NotCallableObject Bases: Exception Source code in dotflow/core/exception.py 37 38 39 40 41 42 43 44 class NotCallableObject ( Exception ): def __init__ ( self , name : str ): super ( NotCallableObject , self ) . __init__ ( MESSAGE_NOT_CALLABLE_OBJECT . format ( name = name ) ) __init__ ( name ) Source code in dotflow/core/exception.py 39 40 41 42 43 44 def __init__ ( self , name : str ): super ( NotCallableObject , self ) . __init__ ( MESSAGE_NOT_CALLABLE_OBJECT . format ( name = name ) ) dotflow.core.exception.ProblemOrdering Bases: Exception Source code in dotflow/core/exception.py 47 48 49 50 51 52 53 54 class ProblemOrdering ( Exception ): def __init__ ( self , name : str ): super ( ProblemOrdering , self ) . __init__ ( MESSAGE_PROBLEM_ORDERING . format ( name = name ) ) __init__ ( name ) Source code in dotflow/core/exception.py 49 50 51 52 53 54 def __init__ ( self , name : str ): super ( ProblemOrdering , self ) . __init__ ( MESSAGE_PROBLEM_ORDERING . format ( name = name ) )","title":"Exception"},{"location":"nav/reference/exception/#exception","text":"","title":"Exception"},{"location":"nav/reference/exception/#dotflow.core.exception.MissingActionDecorator","text":"Bases: Exception Source code in dotflow/core/exception.py 11 12 13 14 15 16 class MissingActionDecorator ( Exception ): def __init__ ( self ): super ( MissingActionDecorator , self ) . __init__ ( MESSAGE_MISSING_STEP_DECORATOR )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;MissingActionDecorator"},{"location":"nav/reference/exception/#dotflow.core.exception.MissingActionDecorator.__init__","text":"Source code in dotflow/core/exception.py 13 14 15 16 def __init__ ( self ): super ( MissingActionDecorator , self ) . __init__ ( MESSAGE_MISSING_STEP_DECORATOR )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__init__"},{"location":"nav/reference/exception/#dotflow.core.exception.ExecutionModeNotExist","text":"Bases: Exception Source code in dotflow/core/exception.py 19 20 21 22 23 24 class ExecutionModeNotExist ( Exception ): def __init__ ( self ): super ( ExecutionModeNotExist , self ) . __init__ ( MESSAGE_EXECUTION_NOT_EXIST )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;ExecutionModeNotExist"},{"location":"nav/reference/exception/#dotflow.core.exception.ExecutionModeNotExist.__init__","text":"Source code in dotflow/core/exception.py 21 22 23 24 def __init__ ( self ): super ( ExecutionModeNotExist , self ) . __init__ ( MESSAGE_EXECUTION_NOT_EXIST )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__init__"},{"location":"nav/reference/exception/#dotflow.core.exception.ImportModuleError","text":"Bases: Exception Source code in dotflow/core/exception.py 27 28 29 30 31 32 33 34 class ImportModuleError ( Exception ): def __init__ ( self , module : str ): super ( ImportModuleError , self ) . __init__ ( MESSAGE_IMPORT_MODULE_ERROR . format ( module = module ) )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;ImportModuleError"},{"location":"nav/reference/exception/#dotflow.core.exception.ImportModuleError.__init__","text":"Source code in dotflow/core/exception.py 29 30 31 32 33 34 def __init__ ( self , module : str ): super ( ImportModuleError , self ) . __init__ ( MESSAGE_IMPORT_MODULE_ERROR . format ( module = module ) )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__init__"},{"location":"nav/reference/exception/#dotflow.core.exception.NotCallableObject","text":"Bases: Exception Source code in dotflow/core/exception.py 37 38 39 40 41 42 43 44 class NotCallableObject ( Exception ): def __init__ ( self , name : str ): super ( NotCallableObject , self ) . __init__ ( MESSAGE_NOT_CALLABLE_OBJECT . format ( name = name ) )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;NotCallableObject"},{"location":"nav/reference/exception/#dotflow.core.exception.NotCallableObject.__init__","text":"Source code in dotflow/core/exception.py 39 40 41 42 43 44 def __init__ ( self , name : str ): super ( NotCallableObject , self ) . __init__ ( MESSAGE_NOT_CALLABLE_OBJECT . format ( name = name ) )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__init__"},{"location":"nav/reference/exception/#dotflow.core.exception.ProblemOrdering","text":"Bases: Exception Source code in dotflow/core/exception.py 47 48 49 50 51 52 53 54 class ProblemOrdering ( Exception ): def __init__ ( self , name : str ): super ( ProblemOrdering , self ) . __init__ ( MESSAGE_PROBLEM_ORDERING . format ( name = name ) )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;ProblemOrdering"},{"location":"nav/reference/exception/#dotflow.core.exception.ProblemOrdering.__init__","text":"Source code in dotflow/core/exception.py 49 50 51 52 53 54 def __init__ ( self , name : str ): super ( ProblemOrdering , self ) . __init__ ( MESSAGE_PROBLEM_ORDERING . format ( name = name ) )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__init__"},{"location":"nav/reference/log-default/","text":"LogDefault dotflow.providers.log_default.LogDefault Bases: Log Source code in dotflow/providers/log_default.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class LogDefault ( Log ): def info ( self , task : Any ) -> None : logger . info ( \"ID %s - %s - %s \" , task . workflow_id , task . task_id , task . status , ) def error ( self , task : Any ) -> None : logger . error ( \"ID %s - %s - %s \\n %s \" , task . workflow_id , task . task_id , task . status , task . error . traceback , ) console = Console () console . print_exception ( show_locals = True ) error ( task ) Source code in dotflow/providers/log_default.py 21 22 23 24 25 26 27 28 29 30 def error ( self , task : Any ) -> None : logger . error ( \"ID %s - %s - %s \\n %s \" , task . workflow_id , task . task_id , task . status , task . error . traceback , ) console = Console () console . print_exception ( show_locals = True ) info ( task ) Source code in dotflow/providers/log_default.py 13 14 15 16 17 18 19 def info ( self , task : Any ) -> None : logger . info ( \"ID %s - %s - %s \" , task . workflow_id , task . task_id , task . status , )","title":"LogDefault"},{"location":"nav/reference/log-default/#logdefault","text":"","title":"LogDefault"},{"location":"nav/reference/log-default/#dotflow.providers.log_default.LogDefault","text":"Bases: Log Source code in dotflow/providers/log_default.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class LogDefault ( Log ): def info ( self , task : Any ) -> None : logger . info ( \"ID %s - %s - %s \" , task . workflow_id , task . task_id , task . status , ) def error ( self , task : Any ) -> None : logger . error ( \"ID %s - %s - %s \\n %s \" , task . workflow_id , task . task_id , task . status , task . error . traceback , ) console = Console () console . print_exception ( show_locals = True )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;LogDefault"},{"location":"nav/reference/log-default/#dotflow.providers.log_default.LogDefault.error","text":"Source code in dotflow/providers/log_default.py 21 22 23 24 25 26 27 28 29 30 def error ( self , task : Any ) -> None : logger . error ( \"ID %s - %s - %s \\n %s \" , task . workflow_id , task . task_id , task . status , task . error . traceback , ) console = Console () console . print_exception ( show_locals = True )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;error"},{"location":"nav/reference/log-default/#dotflow.providers.log_default.LogDefault.info","text":"Source code in dotflow/providers/log_default.py 13 14 15 16 17 18 19 def info ( self , task : Any ) -> None : logger . info ( \"ID %s - %s - %s \" , task . workflow_id , task . task_id , task . status , )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;info"},{"location":"nav/reference/notify-default/","text":"NotifyTelegram dotflow.providers.notify_default.NotifyDefault Bases: Notify Source code in dotflow/providers/notify_default.py 8 9 10 11 class NotifyDefault ( Notify ): def send ( self , task : Any ) -> None : pass send ( task ) Source code in dotflow/providers/notify_default.py 10 11 def send ( self , task : Any ) -> None : pass","title":"NotifyTelegram"},{"location":"nav/reference/notify-default/#notifytelegram","text":"","title":"NotifyTelegram"},{"location":"nav/reference/notify-default/#dotflow.providers.notify_default.NotifyDefault","text":"Bases: Notify Source code in dotflow/providers/notify_default.py 8 9 10 11 class NotifyDefault ( Notify ): def send ( self , task : Any ) -> None : pass","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;NotifyDefault"},{"location":"nav/reference/notify-default/#dotflow.providers.notify_default.NotifyDefault.send","text":"Source code in dotflow/providers/notify_default.py 10 11 def send ( self , task : Any ) -> None : pass","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;send"},{"location":"nav/reference/notify-telegram/","text":"NotifyTelegram dotflow.providers.notify_telegram.NotifyTelegram Bases: Notify Source code in dotflow/providers/notify_telegram.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class NotifyTelegram ( Notify ): MESSAGE = \" {symbol} {status} \\n ```json \\n {task} ``` \\n {workflow_id} - {task_id} \" API_TELEGRAM = \"https://api.telegram.org/bot {token} /sendMessage\" def __init__ ( self , token : str , chat_id : int , notification_type : Optional [ TypeStatus ] = None , timeout : int = 1.5 ): self . token = token self . chat_id = chat_id self . notification_type = notification_type self . timeout = timeout def send ( self , task : Any ) -> None : if not self . notification_type or self . notification_type == task . status : data = { \"chat_id\" : self . chat_id , \"text\" : self . _get_text ( task = task ), \"parse_mode\" : \"markdown\" , } try : response = post ( url = self . API_TELEGRAM . format ( token = self . token ), headers = { \"Content-Type\" : \"application/json\" }, data = dumps ( data ), timeout = self . timeout ) response . raise_for_status () except Exception as error : logger . error ( \"Internal problem sending notification on Telegram: %s \" , str ( error ), ) def _get_text ( self , task : Any ) -> str : return self . MESSAGE . format ( symbol = TypeStatus . get_symbol ( task . status ), status = task . status , workflow_id = task . workflow_id , task_id = task . task_id , task = task . result ( max = 4000 ), ) API_TELEGRAM = 'https://api.telegram.org/bot {token} /sendMessage' class-attribute instance-attribute MESSAGE = ' {symbol} {status} \\n ```json \\n {task} ``` \\n {workflow_id} - {task_id} ' class-attribute instance-attribute chat_id = chat_id instance-attribute notification_type = notification_type instance-attribute timeout = timeout instance-attribute token = token instance-attribute __init__ ( token , chat_id , notification_type = None , timeout = 1.5 ) Source code in dotflow/providers/notify_telegram.py 18 19 20 21 22 23 24 25 26 27 28 def __init__ ( self , token : str , chat_id : int , notification_type : Optional [ TypeStatus ] = None , timeout : int = 1.5 ): self . token = token self . chat_id = chat_id self . notification_type = notification_type self . timeout = timeout send ( task ) Source code in dotflow/providers/notify_telegram.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def send ( self , task : Any ) -> None : if not self . notification_type or self . notification_type == task . status : data = { \"chat_id\" : self . chat_id , \"text\" : self . _get_text ( task = task ), \"parse_mode\" : \"markdown\" , } try : response = post ( url = self . API_TELEGRAM . format ( token = self . token ), headers = { \"Content-Type\" : \"application/json\" }, data = dumps ( data ), timeout = self . timeout ) response . raise_for_status () except Exception as error : logger . error ( \"Internal problem sending notification on Telegram: %s \" , str ( error ), )","title":"NotifyTelegram"},{"location":"nav/reference/notify-telegram/#notifytelegram","text":"","title":"NotifyTelegram"},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram","text":"Bases: Notify Source code in dotflow/providers/notify_telegram.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class NotifyTelegram ( Notify ): MESSAGE = \" {symbol} {status} \\n ```json \\n {task} ``` \\n {workflow_id} - {task_id} \" API_TELEGRAM = \"https://api.telegram.org/bot {token} /sendMessage\" def __init__ ( self , token : str , chat_id : int , notification_type : Optional [ TypeStatus ] = None , timeout : int = 1.5 ): self . token = token self . chat_id = chat_id self . notification_type = notification_type self . timeout = timeout def send ( self , task : Any ) -> None : if not self . notification_type or self . notification_type == task . status : data = { \"chat_id\" : self . chat_id , \"text\" : self . _get_text ( task = task ), \"parse_mode\" : \"markdown\" , } try : response = post ( url = self . API_TELEGRAM . format ( token = self . token ), headers = { \"Content-Type\" : \"application/json\" }, data = dumps ( data ), timeout = self . timeout ) response . raise_for_status () except Exception as error : logger . error ( \"Internal problem sending notification on Telegram: %s \" , str ( error ), ) def _get_text ( self , task : Any ) -> str : return self . MESSAGE . format ( symbol = TypeStatus . get_symbol ( task . status ), status = task . status , workflow_id = task . workflow_id , task_id = task . task_id , task = task . result ( max = 4000 ), )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;NotifyTelegram"},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.API_TELEGRAM","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;API_TELEGRAM"},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.MESSAGE","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;MESSAGE"},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.chat_id","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;chat_id"},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.notification_type","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;notification_type"},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.timeout","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;timeout"},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.token","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;token"},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.__init__","text":"Source code in dotflow/providers/notify_telegram.py 18 19 20 21 22 23 24 25 26 27 28 def __init__ ( self , token : str , chat_id : int , notification_type : Optional [ TypeStatus ] = None , timeout : int = 1.5 ): self . token = token self . chat_id = chat_id self . notification_type = notification_type self . timeout = timeout","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__init__"},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.send","text":"Source code in dotflow/providers/notify_telegram.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def send ( self , task : Any ) -> None : if not self . notification_type or self . notification_type == task . status : data = { \"chat_id\" : self . chat_id , \"text\" : self . _get_text ( task = task ), \"parse_mode\" : \"markdown\" , } try : response = post ( url = self . API_TELEGRAM . format ( token = self . token ), headers = { \"Content-Type\" : \"application/json\" }, data = dumps ( data ), timeout = self . timeout ) response . raise_for_status () except Exception as error : logger . error ( \"Internal problem sending notification on Telegram: %s \" , str ( error ), )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;send"},{"location":"nav/reference/settings/","text":"Settings dotflow.settings.Settings Settings DotFlow Source code in dotflow/settings.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Settings : \"\"\"Settings DotFlow\"\"\" START_PATH = Path ( \".output\" ) GITIGNORE = Path ( \".gitignore\" ) LOG_PROFILE = \"dotflow\" LOG_FILE_NAME = Path ( \"flow.log\" ) LOG_PATH = Path ( \".output/flow.log\" ) LOG_FORMAT = \" %(asctime)s - %(levelname)s [ %(name)s ]: %(message)s \" ICON = \":game_die:\" ERROR_ALERT = f \" { ICON } [bold red]Error:[/bold red]\" INFO_ALERT = f \" { ICON } [bold blue]Info:[/bold blue]\" WARNING_ALERT = f \" { ICON } [bold yellow]Warning:[/bold yellow]\" START_PATH = Path ( '.output' ) class-attribute instance-attribute GITIGNORE = Path ( '.gitignore' ) class-attribute instance-attribute LOG_PROFILE = 'dotflow' class-attribute instance-attribute LOG_FILE_NAME = Path ( 'flow.log' ) class-attribute instance-attribute LOG_PATH = Path ( '.output/flow.log' ) class-attribute instance-attribute LOG_FORMAT = ' %(asctime)s - %(levelname)s [ %(name)s ]: %(message)s ' class-attribute instance-attribute ICON = ':game_die:' class-attribute instance-attribute ERROR_ALERT = f ' { ICON } [bold red]Error:[/bold red]' class-attribute instance-attribute INFO_ALERT = f ' { ICON } [bold blue]Info:[/bold blue]' class-attribute instance-attribute WARNING_ALERT = f ' { ICON } [bold yellow]Warning:[/bold yellow]' class-attribute instance-attribute","title":"Settings"},{"location":"nav/reference/settings/#settings","text":"","title":"Settings"},{"location":"nav/reference/settings/#dotflow.settings.Settings","text":"Settings DotFlow Source code in dotflow/settings.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Settings : \"\"\"Settings DotFlow\"\"\" START_PATH = Path ( \".output\" ) GITIGNORE = Path ( \".gitignore\" ) LOG_PROFILE = \"dotflow\" LOG_FILE_NAME = Path ( \"flow.log\" ) LOG_PATH = Path ( \".output/flow.log\" ) LOG_FORMAT = \" %(asctime)s - %(levelname)s [ %(name)s ]: %(message)s \" ICON = \":game_die:\" ERROR_ALERT = f \" { ICON } [bold red]Error:[/bold red]\" INFO_ALERT = f \" { ICON } [bold blue]Info:[/bold blue]\" WARNING_ALERT = f \" { ICON } [bold yellow]Warning:[/bold yellow]\"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;Settings"},{"location":"nav/reference/settings/#dotflow.settings.Settings.START_PATH","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;START_PATH"},{"location":"nav/reference/settings/#dotflow.settings.Settings.GITIGNORE","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;GITIGNORE"},{"location":"nav/reference/settings/#dotflow.settings.Settings.LOG_PROFILE","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;LOG_PROFILE"},{"location":"nav/reference/settings/#dotflow.settings.Settings.LOG_FILE_NAME","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;LOG_FILE_NAME"},{"location":"nav/reference/settings/#dotflow.settings.Settings.LOG_PATH","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;LOG_PATH"},{"location":"nav/reference/settings/#dotflow.settings.Settings.LOG_FORMAT","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;LOG_FORMAT"},{"location":"nav/reference/settings/#dotflow.settings.Settings.ICON","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;ICON"},{"location":"nav/reference/settings/#dotflow.settings.Settings.ERROR_ALERT","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;ERROR_ALERT"},{"location":"nav/reference/settings/#dotflow.settings.Settings.INFO_ALERT","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;INFO_ALERT"},{"location":"nav/reference/settings/#dotflow.settings.Settings.WARNING_ALERT","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;WARNING_ALERT"},{"location":"nav/reference/storage-file/","text":"StorageFile dotflow.providers.storage_file.StorageFile Bases: Storage Storage Source code in dotflow/providers/storage_file.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class StorageFile ( Storage ): \"\"\"Storage\"\"\" def __init__ ( self , * args , path : str = settings . START_PATH , ** kwargs ): self . path = Path ( path , \"tasks\" ) self . path . mkdir ( parents = True , exist_ok = True ) def post ( self , key : str , context : Context ) -> None : task_context = [] if Path ( self . path , key ) . exists (): task_context = read_file ( path = Path ( self . path , key )) if isinstance ( context . storage , list ): for item in context . storage : if isinstance ( item , Context ): task_context . append ( self . _dumps ( storage = item . storage )) write_file ( path = Path ( self . path , key ), content = task_context , mode = \"a\" ) return None task_context . append ( self . _dumps ( storage = context . storage )) write_file ( path = Path ( self . path , key ), content = task_context ) return None def get ( self , key : str ) -> Context : task_context = [] if Path ( self . path , key ) . exists (): task_context = read_file ( path = Path ( self . path , key )) if len ( task_context ) == 1 : return self . _loads ( storage = task_context [ 0 ]) contexts = Context ( storage = []) for context in task_context : contexts . storage . append ( self . _loads ( storage = context )) return contexts def key ( self , task : Callable ): return f \" { task . workflow_id } - { task . task_id } .json\" def _loads ( self , storage : Any ) -> Context : try : return Context ( storage = loads ( storage )) except Exception : return Context ( storage = storage ) def _dumps ( self , storage : Any ) -> str : try : return dumps ( storage ) except TypeError : return str ( storage ) path = Path ( path , 'tasks' ) instance-attribute __init__ ( * args , path = settings . START_PATH , ** kwargs ) Source code in dotflow/providers/storage_file.py 16 17 18 def __init__ ( self , * args , path : str = settings . START_PATH , ** kwargs ): self . path = Path ( path , \"tasks\" ) self . path . mkdir ( parents = True , exist_ok = True ) get ( key ) Source code in dotflow/providers/storage_file.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def get ( self , key : str ) -> Context : task_context = [] if Path ( self . path , key ) . exists (): task_context = read_file ( path = Path ( self . path , key )) if len ( task_context ) == 1 : return self . _loads ( storage = task_context [ 0 ]) contexts = Context ( storage = []) for context in task_context : contexts . storage . append ( self . _loads ( storage = context )) return contexts key ( task ) Source code in dotflow/providers/storage_file.py 53 54 def key ( self , task : Callable ): return f \" { task . workflow_id } - { task . task_id } .json\" post ( key , context ) Source code in dotflow/providers/storage_file.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def post ( self , key : str , context : Context ) -> None : task_context = [] if Path ( self . path , key ) . exists (): task_context = read_file ( path = Path ( self . path , key )) if isinstance ( context . storage , list ): for item in context . storage : if isinstance ( item , Context ): task_context . append ( self . _dumps ( storage = item . storage )) write_file ( path = Path ( self . path , key ), content = task_context , mode = \"a\" ) return None task_context . append ( self . _dumps ( storage = context . storage )) write_file ( path = Path ( self . path , key ), content = task_context ) return None","title":"StorageFile"},{"location":"nav/reference/storage-file/#storagefile","text":"","title":"StorageFile"},{"location":"nav/reference/storage-file/#dotflow.providers.storage_file.StorageFile","text":"Bases: Storage Storage Source code in dotflow/providers/storage_file.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class StorageFile ( Storage ): \"\"\"Storage\"\"\" def __init__ ( self , * args , path : str = settings . START_PATH , ** kwargs ): self . path = Path ( path , \"tasks\" ) self . path . mkdir ( parents = True , exist_ok = True ) def post ( self , key : str , context : Context ) -> None : task_context = [] if Path ( self . path , key ) . exists (): task_context = read_file ( path = Path ( self . path , key )) if isinstance ( context . storage , list ): for item in context . storage : if isinstance ( item , Context ): task_context . append ( self . _dumps ( storage = item . storage )) write_file ( path = Path ( self . path , key ), content = task_context , mode = \"a\" ) return None task_context . append ( self . _dumps ( storage = context . storage )) write_file ( path = Path ( self . path , key ), content = task_context ) return None def get ( self , key : str ) -> Context : task_context = [] if Path ( self . path , key ) . exists (): task_context = read_file ( path = Path ( self . path , key )) if len ( task_context ) == 1 : return self . _loads ( storage = task_context [ 0 ]) contexts = Context ( storage = []) for context in task_context : contexts . storage . append ( self . _loads ( storage = context )) return contexts def key ( self , task : Callable ): return f \" { task . workflow_id } - { task . task_id } .json\" def _loads ( self , storage : Any ) -> Context : try : return Context ( storage = loads ( storage )) except Exception : return Context ( storage = storage ) def _dumps ( self , storage : Any ) -> str : try : return dumps ( storage ) except TypeError : return str ( storage )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;StorageFile"},{"location":"nav/reference/storage-file/#dotflow.providers.storage_file.StorageFile.path","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;path"},{"location":"nav/reference/storage-file/#dotflow.providers.storage_file.StorageFile.__init__","text":"Source code in dotflow/providers/storage_file.py 16 17 18 def __init__ ( self , * args , path : str = settings . START_PATH , ** kwargs ): self . path = Path ( path , \"tasks\" ) self . path . mkdir ( parents = True , exist_ok = True )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__init__"},{"location":"nav/reference/storage-file/#dotflow.providers.storage_file.StorageFile.get","text":"Source code in dotflow/providers/storage_file.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def get ( self , key : str ) -> Context : task_context = [] if Path ( self . path , key ) . exists (): task_context = read_file ( path = Path ( self . path , key )) if len ( task_context ) == 1 : return self . _loads ( storage = task_context [ 0 ]) contexts = Context ( storage = []) for context in task_context : contexts . storage . append ( self . _loads ( storage = context )) return contexts","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;get"},{"location":"nav/reference/storage-file/#dotflow.providers.storage_file.StorageFile.key","text":"Source code in dotflow/providers/storage_file.py 53 54 def key ( self , task : Callable ): return f \" { task . workflow_id } - { task . task_id } .json\"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;key"},{"location":"nav/reference/storage-file/#dotflow.providers.storage_file.StorageFile.post","text":"Source code in dotflow/providers/storage_file.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def post ( self , key : str , context : Context ) -> None : task_context = [] if Path ( self . path , key ) . exists (): task_context = read_file ( path = Path ( self . path , key )) if isinstance ( context . storage , list ): for item in context . storage : if isinstance ( item , Context ): task_context . append ( self . _dumps ( storage = item . storage )) write_file ( path = Path ( self . path , key ), content = task_context , mode = \"a\" ) return None task_context . append ( self . _dumps ( storage = context . storage )) write_file ( path = Path ( self . path , key ), content = task_context ) return None","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;post"},{"location":"nav/reference/storage-init/","text":"StorageDefault dotflow.providers.storage_default.StorageDefault Bases: Storage Storage Source code in dotflow/providers/storage_default.py 10 11 12 13 14 15 16 17 18 19 20 class StorageDefault ( Storage ): \"\"\"Storage\"\"\" def post ( self , key : str , context : Context ) -> None : return None def get ( self , key : str ) -> Context : return Context ( storage = cast ( key , py_object ) . value ) def key ( self , task : Callable ): return id ( task . current_context ) get ( key ) Source code in dotflow/providers/storage_default.py 16 17 def get ( self , key : str ) -> Context : return Context ( storage = cast ( key , py_object ) . value ) key ( task ) Source code in dotflow/providers/storage_default.py 19 20 def key ( self , task : Callable ): return id ( task . current_context ) post ( key , context ) Source code in dotflow/providers/storage_default.py 13 14 def post ( self , key : str , context : Context ) -> None : return None","title":"StorageDefault"},{"location":"nav/reference/storage-init/#storagedefault","text":"","title":"StorageDefault"},{"location":"nav/reference/storage-init/#dotflow.providers.storage_default.StorageDefault","text":"Bases: Storage Storage Source code in dotflow/providers/storage_default.py 10 11 12 13 14 15 16 17 18 19 20 class StorageDefault ( Storage ): \"\"\"Storage\"\"\" def post ( self , key : str , context : Context ) -> None : return None def get ( self , key : str ) -> Context : return Context ( storage = cast ( key , py_object ) . value ) def key ( self , task : Callable ): return id ( task . current_context )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;StorageDefault"},{"location":"nav/reference/storage-init/#dotflow.providers.storage_default.StorageDefault.get","text":"Source code in dotflow/providers/storage_default.py 16 17 def get ( self , key : str ) -> Context : return Context ( storage = cast ( key , py_object ) . value )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;get"},{"location":"nav/reference/storage-init/#dotflow.providers.storage_default.StorageDefault.key","text":"Source code in dotflow/providers/storage_default.py 19 20 def key ( self , task : Callable ): return id ( task . current_context )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;key"},{"location":"nav/reference/storage-init/#dotflow.providers.storage_default.StorageDefault.post","text":"Source code in dotflow/providers/storage_default.py 13 14 def post ( self , key : str , context : Context ) -> None : return None","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;post"},{"location":"nav/reference/task-builder/","text":"TaskBuilder dotflow.core.task.TaskBuilder Import You can import the Task class with: from dotflow.core.task import TaskBuilder Example class dotflow.core.task.TaskBuilder from uuid import uuid4 build = TaskBuilder( config=config workflow_id=uuid4() ) Parameters: Name Type Description Default config Config Configuration class. required workflow_id UUID Workflow ID. None Source code in dotflow/core/task.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 class TaskBuilder : \"\"\" Import: You can import the **Task** class with: from dotflow.core.task import TaskBuilder Example: `class` dotflow.core.task.TaskBuilder from uuid import uuid4 build = TaskBuilder( config=config workflow_id=uuid4() ) Args: config (Config): Configuration class. workflow_id (UUID): Workflow ID. \"\"\" def __init__ ( self , config : Config , workflow_id : UUID = None ) -> None : self . queue : List [ Callable ] = [] self . workflow_id = workflow_id self . config = config def add ( self , step : Callable , callback : Callable = basic_callback , initial_context : Any = None , group_name : str = \"default\" ) -> None : \"\"\" Args: step (Callable): A argument that receives an object of the callable type, which is basically a function. You can see in this [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#3-task-function). callback (Callable): Any callable object that receives **args** or **kwargs**, which is basically a function. You can see in this [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#2-callback-function). initial_context (Context): The argument exists to include initial data in the execution of the workflow within the **function context**. This parameter can be accessed internally, for example: **initial_context**, to retrieve this information and manipulate it if necessary, according to the objective of the workflow. group_name (str): Group name of tasks. \"\"\" if isinstance ( step , list ): for inside_step in step : self . add ( step = inside_step , callback = callback , initial_context = initial_context , group_name = group_name ) return self self . queue . append ( Task ( task_id = len ( self . queue ), step = step , callback = Module ( value = callback ), initial_context = initial_context , workflow_id = self . workflow_id , config = self . config , group_name = group_name ) ) return self def count ( self ) -> int : return len ( self . queue ) def clear ( self ) -> None : self . queue . clear () def reverse ( self ) -> None : self . queue . reverse () def schema ( self ) -> SerializerWorkflow : return SerializerWorkflow ( workflow_id = self . workflow_id , tasks = [ item . schema () for item in self . queue ] ) def result ( self ) -> SerializerWorkflow : item = self . schema () . model_dump_json () return json . loads ( item ) add ( step , callback = basic_callback , initial_context = None , group_name = 'default' ) Parameters: Name Type Description Default step Callable A argument that receives an object of the callable type, which is basically a function. You can see in this example . required callback Callable Any callable object that receives args or kwargs , which is basically a function. You can see in this example . basic_callback initial_context Context The argument exists to include initial data in the execution of the workflow within the function context . This parameter can be accessed internally, for example: initial_context , to retrieve this information and manipulate it if necessary, according to the objective of the workflow. None group_name str Group name of tasks. 'default' Source code in dotflow/core/task.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 def add ( self , step : Callable , callback : Callable = basic_callback , initial_context : Any = None , group_name : str = \"default\" ) -> None : \"\"\" Args: step (Callable): A argument that receives an object of the callable type, which is basically a function. You can see in this [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#3-task-function). callback (Callable): Any callable object that receives **args** or **kwargs**, which is basically a function. You can see in this [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#2-callback-function). initial_context (Context): The argument exists to include initial data in the execution of the workflow within the **function context**. This parameter can be accessed internally, for example: **initial_context**, to retrieve this information and manipulate it if necessary, according to the objective of the workflow. group_name (str): Group name of tasks. \"\"\" if isinstance ( step , list ): for inside_step in step : self . add ( step = inside_step , callback = callback , initial_context = initial_context , group_name = group_name ) return self self . queue . append ( Task ( task_id = len ( self . queue ), step = step , callback = Module ( value = callback ), initial_context = initial_context , workflow_id = self . workflow_id , config = self . config , group_name = group_name ) ) return self count () Source code in dotflow/core/task.py 330 331 def count ( self ) -> int : return len ( self . queue ) clear () Source code in dotflow/core/task.py 333 334 def clear ( self ) -> None : self . queue . clear () reverse () Source code in dotflow/core/task.py 336 337 def reverse ( self ) -> None : self . queue . reverse ()","title":"TaskBuilder"},{"location":"nav/reference/task-builder/#taskbuilder","text":"","title":"TaskBuilder"},{"location":"nav/reference/task-builder/#dotflow.core.task.TaskBuilder","text":"Import You can import the Task class with: from dotflow.core.task import TaskBuilder Example class dotflow.core.task.TaskBuilder from uuid import uuid4 build = TaskBuilder( config=config workflow_id=uuid4() ) Parameters: Name Type Description Default config Config Configuration class. required workflow_id UUID Workflow ID. None Source code in dotflow/core/task.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 class TaskBuilder : \"\"\" Import: You can import the **Task** class with: from dotflow.core.task import TaskBuilder Example: `class` dotflow.core.task.TaskBuilder from uuid import uuid4 build = TaskBuilder( config=config workflow_id=uuid4() ) Args: config (Config): Configuration class. workflow_id (UUID): Workflow ID. \"\"\" def __init__ ( self , config : Config , workflow_id : UUID = None ) -> None : self . queue : List [ Callable ] = [] self . workflow_id = workflow_id self . config = config def add ( self , step : Callable , callback : Callable = basic_callback , initial_context : Any = None , group_name : str = \"default\" ) -> None : \"\"\" Args: step (Callable): A argument that receives an object of the callable type, which is basically a function. You can see in this [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#3-task-function). callback (Callable): Any callable object that receives **args** or **kwargs**, which is basically a function. You can see in this [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#2-callback-function). initial_context (Context): The argument exists to include initial data in the execution of the workflow within the **function context**. This parameter can be accessed internally, for example: **initial_context**, to retrieve this information and manipulate it if necessary, according to the objective of the workflow. group_name (str): Group name of tasks. \"\"\" if isinstance ( step , list ): for inside_step in step : self . add ( step = inside_step , callback = callback , initial_context = initial_context , group_name = group_name ) return self self . queue . append ( Task ( task_id = len ( self . queue ), step = step , callback = Module ( value = callback ), initial_context = initial_context , workflow_id = self . workflow_id , config = self . config , group_name = group_name ) ) return self def count ( self ) -> int : return len ( self . queue ) def clear ( self ) -> None : self . queue . clear () def reverse ( self ) -> None : self . queue . reverse () def schema ( self ) -> SerializerWorkflow : return SerializerWorkflow ( workflow_id = self . workflow_id , tasks = [ item . schema () for item in self . queue ] ) def result ( self ) -> SerializerWorkflow : item = self . schema () . model_dump_json () return json . loads ( item )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;TaskBuilder"},{"location":"nav/reference/task-builder/#dotflow.core.task.TaskBuilder.add","text":"Parameters: Name Type Description Default step Callable A argument that receives an object of the callable type, which is basically a function. You can see in this example . required callback Callable Any callable object that receives args or kwargs , which is basically a function. You can see in this example . basic_callback initial_context Context The argument exists to include initial data in the execution of the workflow within the function context . This parameter can be accessed internally, for example: initial_context , to retrieve this information and manipulate it if necessary, according to the objective of the workflow. None group_name str Group name of tasks. 'default' Source code in dotflow/core/task.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 def add ( self , step : Callable , callback : Callable = basic_callback , initial_context : Any = None , group_name : str = \"default\" ) -> None : \"\"\" Args: step (Callable): A argument that receives an object of the callable type, which is basically a function. You can see in this [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#3-task-function). callback (Callable): Any callable object that receives **args** or **kwargs**, which is basically a function. You can see in this [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#2-callback-function). initial_context (Context): The argument exists to include initial data in the execution of the workflow within the **function context**. This parameter can be accessed internally, for example: **initial_context**, to retrieve this information and manipulate it if necessary, according to the objective of the workflow. group_name (str): Group name of tasks. \"\"\" if isinstance ( step , list ): for inside_step in step : self . add ( step = inside_step , callback = callback , initial_context = initial_context , group_name = group_name ) return self self . queue . append ( Task ( task_id = len ( self . queue ), step = step , callback = Module ( value = callback ), initial_context = initial_context , workflow_id = self . workflow_id , config = self . config , group_name = group_name ) ) return self","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;add"},{"location":"nav/reference/task-builder/#dotflow.core.task.TaskBuilder.count","text":"Source code in dotflow/core/task.py 330 331 def count ( self ) -> int : return len ( self . queue )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;count"},{"location":"nav/reference/task-builder/#dotflow.core.task.TaskBuilder.clear","text":"Source code in dotflow/core/task.py 333 334 def clear ( self ) -> None : self . queue . clear ()","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;clear"},{"location":"nav/reference/task-builder/#dotflow.core.task.TaskBuilder.reverse","text":"Source code in dotflow/core/task.py 336 337 def reverse ( self ) -> None : self . queue . reverse ()","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;reverse"},{"location":"nav/reference/task-error/","text":"TaskError dotflow.core.task.TaskError Source code in dotflow/core/task.py 239 240 241 242 243 244 class TaskError : def __init__ ( self , error : Exception = None ) -> None : self . exception = error self . traceback = traceback_error ( error = error ) if error else \"\" self . message = message_error ( error = error ) if error else \"\" exception = error instance-attribute message = message_error ( error = error ) if error else '' instance-attribute traceback = traceback_error ( error = error ) if error else '' instance-attribute __init__ ( error = None ) Source code in dotflow/core/task.py 241 242 243 244 def __init__ ( self , error : Exception = None ) -> None : self . exception = error self . traceback = traceback_error ( error = error ) if error else \"\" self . message = message_error ( error = error ) if error else \"\"","title":"TaskError"},{"location":"nav/reference/task-error/#taskerror","text":"","title":"TaskError"},{"location":"nav/reference/task-error/#dotflow.core.task.TaskError","text":"Source code in dotflow/core/task.py 239 240 241 242 243 244 class TaskError : def __init__ ( self , error : Exception = None ) -> None : self . exception = error self . traceback = traceback_error ( error = error ) if error else \"\" self . message = message_error ( error = error ) if error else \"\"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;TaskError"},{"location":"nav/reference/task-error/#dotflow.core.task.TaskError.exception","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;exception"},{"location":"nav/reference/task-error/#dotflow.core.task.TaskError.message","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;message"},{"location":"nav/reference/task-error/#dotflow.core.task.TaskError.traceback","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;traceback"},{"location":"nav/reference/task-error/#dotflow.core.task.TaskError.__init__","text":"Source code in dotflow/core/task.py 241 242 243 244 def __init__ ( self , error : Exception = None ) -> None : self . exception = error self . traceback = traceback_error ( error = error ) if error else \"\" self . message = message_error ( error = error ) if error else \"\"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__init__"},{"location":"nav/reference/task-instance/","text":"TaskInstance dotflow.core.task.TaskInstance Import You can import the TaskInstance class with: from dotflow.core.task import TaskInstance Source code in dotflow/core/task.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class TaskInstance : \"\"\" Import: You can import the **TaskInstance** class with: from dotflow.core.task import TaskInstance \"\"\" def __init__ ( self , * args , ** kwargs ) -> None : self . task_id = None self . workflow_id = None self . _step = None self . _callback = None self . _previous_context = None self . _initial_context = None self . _current_context = None self . _duration = None self . _error = None self . _status = None self . _config = None self . group_name = None task_id = None instance-attribute workflow_id = None instance-attribute _step = None instance-attribute _callback = None instance-attribute _previous_context = None instance-attribute _initial_context = None instance-attribute _current_context = None instance-attribute _duration = None instance-attribute _error = None instance-attribute _status = None instance-attribute _config = None instance-attribute group_name = None instance-attribute","title":"TaskInstance"},{"location":"nav/reference/task-instance/#taskinstance","text":"","title":"TaskInstance"},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance","text":"Import You can import the TaskInstance class with: from dotflow.core.task import TaskInstance Source code in dotflow/core/task.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class TaskInstance : \"\"\" Import: You can import the **TaskInstance** class with: from dotflow.core.task import TaskInstance \"\"\" def __init__ ( self , * args , ** kwargs ) -> None : self . task_id = None self . workflow_id = None self . _step = None self . _callback = None self . _previous_context = None self . _initial_context = None self . _current_context = None self . _duration = None self . _error = None self . _status = None self . _config = None self . group_name = None","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;TaskInstance"},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance.task_id","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;task_id"},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance.workflow_id","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;workflow_id"},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._step","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;_step"},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._callback","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;_callback"},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._previous_context","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;_previous_context"},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._initial_context","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;_initial_context"},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._current_context","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;_current_context"},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._duration","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;_duration"},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._error","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;_error"},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._status","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;_status"},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._config","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;_config"},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance.group_name","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;group_name"},{"location":"nav/reference/task/","text":"Task dotflow.core.task.Task Bases: TaskInstance Import You can import the Task class directly from dotflow: from dotflow import Task Example class dotflow.core.task.Task task = Task( task_id=1, step=my_step, callback=my_callback ) Parameters: Name Type Description Default task_id int Task ID. required step Callable A argument that receives an object of the callable type, which is basically a function. You can see in this example . required callback Callable Any callable object that receives args or kwargs , which is basically a function. You can see in this example . basic_callback initial_context Any Any python object. None workflow_id UUID Workflow ID. None config Config Configuration class. None group_name str Group name of tasks. 'default' Source code in dotflow/core/task.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 class Task ( TaskInstance ): \"\"\" Import: You can import the **Task** class directly from dotflow: from dotflow import Task Example: `class` dotflow.core.task.Task task = Task( task_id=1, step=my_step, callback=my_callback ) Args: task_id (int): Task ID. step (Callable): A argument that receives an object of the callable type, which is basically a function. You can see in this [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#3-task-function). callback (Callable): Any callable object that receives **args** or **kwargs**, which is basically a function. You can see in this [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#2-callback-function). initial_context (Any): Any python object. workflow_id (UUID): Workflow ID. config (Config): Configuration class. group_name (str): Group name of tasks. \"\"\" def __init__ ( self , task_id : int , step : Callable , callback : Callable = basic_callback , initial_context : Any = None , workflow_id : UUID = None , config : Config = None , group_name : str = \"default\" ) -> None : super () . __init__ ( task_id , step , callback , initial_context , workflow_id , config , group_name ) self . config = config self . group_name = group_name self . task_id = task_id self . workflow_id = workflow_id self . step = step self . callback = callback self . initial_context = initial_context self . status = TypeStatus . NOT_STARTED @property def step ( self ): return self . _step @step . setter def step ( self , value : Callable ): new_step = value if isinstance ( value , str ): new_step = Module ( value = value ) if new_step . __module__ != Action . __module__ : raise MissingActionDecorator () self . _step = new_step @property def callback ( self ): return self . _callback @callback . setter def callback ( self , value : Callable ): new_callback = value if isinstance ( value , str ): new_callback = Module ( value = value ) if not isinstance ( new_callback , Callable ): raise NotCallableObject ( name = str ( new_callback )) self . _callback = new_callback @property def previous_context ( self ): if not self . _previous_context : return Context () return self . _previous_context @previous_context . setter def previous_context ( self , value : Context ): self . _previous_context = Context ( value ) @property def initial_context ( self ): if not self . _initial_context : return Context () return self . _initial_context @initial_context . setter def initial_context ( self , value : Context ): self . _initial_context = Context ( value ) @property def current_context ( self ): if not self . _current_context : return Context () return self . _current_context @current_context . setter def current_context ( self , value : Context ): self . _current_context = Context ( task_id = self . task_id , workflow_id = self . workflow_id , storage = value ) self . config . storage . post ( key = self . config . storage . key ( task = self ), context = self . current_context ) @property def duration ( self ): return self . _duration @duration . setter def duration ( self , value : float ): self . _duration = value @property def error ( self ): if not self . _error : return TaskError () return self . _error @error . setter def error ( self , value : Exception ) -> None : if isinstance ( value , TaskError ): self . _error = value if isinstance ( value , Exception ): task_error = TaskError ( value ) self . _error = task_error self . config . log . error ( task = self ) @property def status ( self ): if not self . _status : return TypeStatus . NOT_STARTED return self . _status @status . setter def status ( self , value : TypeStatus ) -> None : self . _status = value self . config . notify . send ( task = self ) self . config . log . info ( task = self ) @property def config ( self ): if not self . _config : return Config () return self . _config @config . setter def config ( self , value : Config ): self . _config = value def schema ( self , max : int = None ) -> SerializerTask : return SerializerTask ( ** self . __dict__ , max = max ) def result ( self , max : int = None ) -> SerializerWorkflow : item = self . schema ( max = max ) . model_dump_json () return json . loads ( item ) callback property writable config property writable current_context property writable duration property writable error property writable group_name = group_name instance-attribute initial_context property writable previous_context property writable status property writable step property writable task_id = task_id instance-attribute workflow_id = workflow_id instance-attribute __init__ ( task_id , step , callback = basic_callback , initial_context = None , workflow_id = None , config = None , group_name = 'default' ) Source code in dotflow/core/task.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def __init__ ( self , task_id : int , step : Callable , callback : Callable = basic_callback , initial_context : Any = None , workflow_id : UUID = None , config : Config = None , group_name : str = \"default\" ) -> None : super () . __init__ ( task_id , step , callback , initial_context , workflow_id , config , group_name ) self . config = config self . group_name = group_name self . task_id = task_id self . workflow_id = workflow_id self . step = step self . callback = callback self . initial_context = initial_context self . status = TypeStatus . NOT_STARTED result ( max = None ) Source code in dotflow/core/task.py 234 235 236 def result ( self , max : int = None ) -> SerializerWorkflow : item = self . schema ( max = max ) . model_dump_json () return json . loads ( item ) schema ( max = None ) Source code in dotflow/core/task.py 231 232 def schema ( self , max : int = None ) -> SerializerTask : return SerializerTask ( ** self . __dict__ , max = max )","title":"Task"},{"location":"nav/reference/task/#task","text":"","title":"Task"},{"location":"nav/reference/task/#dotflow.core.task.Task","text":"Bases: TaskInstance Import You can import the Task class directly from dotflow: from dotflow import Task Example class dotflow.core.task.Task task = Task( task_id=1, step=my_step, callback=my_callback ) Parameters: Name Type Description Default task_id int Task ID. required step Callable A argument that receives an object of the callable type, which is basically a function. You can see in this example . required callback Callable Any callable object that receives args or kwargs , which is basically a function. You can see in this example . basic_callback initial_context Any Any python object. None workflow_id UUID Workflow ID. None config Config Configuration class. None group_name str Group name of tasks. 'default' Source code in dotflow/core/task.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 class Task ( TaskInstance ): \"\"\" Import: You can import the **Task** class directly from dotflow: from dotflow import Task Example: `class` dotflow.core.task.Task task = Task( task_id=1, step=my_step, callback=my_callback ) Args: task_id (int): Task ID. step (Callable): A argument that receives an object of the callable type, which is basically a function. You can see in this [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#3-task-function). callback (Callable): Any callable object that receives **args** or **kwargs**, which is basically a function. You can see in this [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#2-callback-function). initial_context (Any): Any python object. workflow_id (UUID): Workflow ID. config (Config): Configuration class. group_name (str): Group name of tasks. \"\"\" def __init__ ( self , task_id : int , step : Callable , callback : Callable = basic_callback , initial_context : Any = None , workflow_id : UUID = None , config : Config = None , group_name : str = \"default\" ) -> None : super () . __init__ ( task_id , step , callback , initial_context , workflow_id , config , group_name ) self . config = config self . group_name = group_name self . task_id = task_id self . workflow_id = workflow_id self . step = step self . callback = callback self . initial_context = initial_context self . status = TypeStatus . NOT_STARTED @property def step ( self ): return self . _step @step . setter def step ( self , value : Callable ): new_step = value if isinstance ( value , str ): new_step = Module ( value = value ) if new_step . __module__ != Action . __module__ : raise MissingActionDecorator () self . _step = new_step @property def callback ( self ): return self . _callback @callback . setter def callback ( self , value : Callable ): new_callback = value if isinstance ( value , str ): new_callback = Module ( value = value ) if not isinstance ( new_callback , Callable ): raise NotCallableObject ( name = str ( new_callback )) self . _callback = new_callback @property def previous_context ( self ): if not self . _previous_context : return Context () return self . _previous_context @previous_context . setter def previous_context ( self , value : Context ): self . _previous_context = Context ( value ) @property def initial_context ( self ): if not self . _initial_context : return Context () return self . _initial_context @initial_context . setter def initial_context ( self , value : Context ): self . _initial_context = Context ( value ) @property def current_context ( self ): if not self . _current_context : return Context () return self . _current_context @current_context . setter def current_context ( self , value : Context ): self . _current_context = Context ( task_id = self . task_id , workflow_id = self . workflow_id , storage = value ) self . config . storage . post ( key = self . config . storage . key ( task = self ), context = self . current_context ) @property def duration ( self ): return self . _duration @duration . setter def duration ( self , value : float ): self . _duration = value @property def error ( self ): if not self . _error : return TaskError () return self . _error @error . setter def error ( self , value : Exception ) -> None : if isinstance ( value , TaskError ): self . _error = value if isinstance ( value , Exception ): task_error = TaskError ( value ) self . _error = task_error self . config . log . error ( task = self ) @property def status ( self ): if not self . _status : return TypeStatus . NOT_STARTED return self . _status @status . setter def status ( self , value : TypeStatus ) -> None : self . _status = value self . config . notify . send ( task = self ) self . config . log . info ( task = self ) @property def config ( self ): if not self . _config : return Config () return self . _config @config . setter def config ( self , value : Config ): self . _config = value def schema ( self , max : int = None ) -> SerializerTask : return SerializerTask ( ** self . __dict__ , max = max ) def result ( self , max : int = None ) -> SerializerWorkflow : item = self . schema ( max = max ) . model_dump_json () return json . loads ( item )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;Task"},{"location":"nav/reference/task/#dotflow.core.task.Task.callback","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;callback"},{"location":"nav/reference/task/#dotflow.core.task.Task.config","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;config"},{"location":"nav/reference/task/#dotflow.core.task.Task.current_context","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;current_context"},{"location":"nav/reference/task/#dotflow.core.task.Task.duration","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;duration"},{"location":"nav/reference/task/#dotflow.core.task.Task.error","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;error"},{"location":"nav/reference/task/#dotflow.core.task.Task.group_name","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;group_name"},{"location":"nav/reference/task/#dotflow.core.task.Task.initial_context","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;initial_context"},{"location":"nav/reference/task/#dotflow.core.task.Task.previous_context","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;previous_context"},{"location":"nav/reference/task/#dotflow.core.task.Task.status","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;status"},{"location":"nav/reference/task/#dotflow.core.task.Task.step","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;step"},{"location":"nav/reference/task/#dotflow.core.task.Task.task_id","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;task_id"},{"location":"nav/reference/task/#dotflow.core.task.Task.workflow_id","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;workflow_id"},{"location":"nav/reference/task/#dotflow.core.task.Task.__init__","text":"Source code in dotflow/core/task.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def __init__ ( self , task_id : int , step : Callable , callback : Callable = basic_callback , initial_context : Any = None , workflow_id : UUID = None , config : Config = None , group_name : str = \"default\" ) -> None : super () . __init__ ( task_id , step , callback , initial_context , workflow_id , config , group_name ) self . config = config self . group_name = group_name self . task_id = task_id self . workflow_id = workflow_id self . step = step self . callback = callback self . initial_context = initial_context self . status = TypeStatus . NOT_STARTED","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__init__"},{"location":"nav/reference/task/#dotflow.core.task.Task.result","text":"Source code in dotflow/core/task.py 234 235 236 def result ( self , max : int = None ) -> SerializerWorkflow : item = self . schema ( max = max ) . model_dump_json () return json . loads ( item )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;result"},{"location":"nav/reference/task/#dotflow.core.task.Task.schema","text":"Source code in dotflow/core/task.py 231 232 def schema ( self , max : int = None ) -> SerializerTask : return SerializerTask ( ** self . __dict__ , max = max )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;schema"},{"location":"nav/reference/type-execution/","text":"TypeExecution dotflow.core.types.execution.TypeExecution Import You can import the TypeExecution class with: from dotflow.core.types import TypeExecution Source code in dotflow/core/types/execution.py 6 7 8 9 10 11 12 13 14 15 16 class TypeExecution : \"\"\" Import: You can import the **TypeExecution** class with: from dotflow.core.types import TypeExecution \"\"\" SEQUENTIAL : Annotated [ str , Doc ( \"Sequential execution.\" )] = \"sequential\" BACKGROUND : Annotated [ str , Doc ( \"Background execution.\" )] = \"background\" PARALLEL : Annotated [ str , Doc ( \"Parallel execution.\" )] = \"parallel\" SEQUENTIAL = 'sequential' class-attribute instance-attribute Sequential execution. BACKGROUND = 'background' class-attribute instance-attribute Background execution. PARALLEL = 'parallel' class-attribute instance-attribute Parallel execution.","title":"TypeExecution"},{"location":"nav/reference/type-execution/#typeexecution","text":"","title":"TypeExecution"},{"location":"nav/reference/type-execution/#dotflow.core.types.execution.TypeExecution","text":"Import You can import the TypeExecution class with: from dotflow.core.types import TypeExecution Source code in dotflow/core/types/execution.py 6 7 8 9 10 11 12 13 14 15 16 class TypeExecution : \"\"\" Import: You can import the **TypeExecution** class with: from dotflow.core.types import TypeExecution \"\"\" SEQUENTIAL : Annotated [ str , Doc ( \"Sequential execution.\" )] = \"sequential\" BACKGROUND : Annotated [ str , Doc ( \"Background execution.\" )] = \"background\" PARALLEL : Annotated [ str , Doc ( \"Parallel execution.\" )] = \"parallel\"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;TypeExecution"},{"location":"nav/reference/type-execution/#dotflow.core.types.execution.TypeExecution.SEQUENTIAL","text":"Sequential execution.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;SEQUENTIAL"},{"location":"nav/reference/type-execution/#dotflow.core.types.execution.TypeExecution.BACKGROUND","text":"Background execution.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;BACKGROUND"},{"location":"nav/reference/type-execution/#dotflow.core.types.execution.TypeExecution.PARALLEL","text":"Parallel execution.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;PARALLEL"},{"location":"nav/reference/type-status/","text":"TypeStatus dotflow.core.types.status.TypeStatus Import You can import the TypeStatus class with: from dotflow.core.types import TypeStatus Source code in dotflow/core/types/status.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class TypeStatus : \"\"\" Import: You can import the **TypeStatus** class with: from dotflow.core.types import TypeStatus \"\"\" NOT_STARTED : Annotated [ str , Doc ( \"Status not started.\" )] = \"Not started\" IN_PROGRESS : Annotated [ str , Doc ( \"Status in progress.\" )] = \"In progress\" COMPLETED : Annotated [ str , Doc ( \"Status completed.\" )] = \"Completed\" PAUSED : Annotated [ str , Doc ( \"Status paused.\" )] = \"Paused\" RETRY : Annotated [ str , Doc ( \"Status retry.\" )] = \"Retry\" FAILED : Annotated [ str , Doc ( \"Status failed.\" )] = \"Failed\" @classmethod def get_symbol ( cls , value : str ) -> str : status = { TypeStatus . NOT_STARTED : \"\u26aa\" , TypeStatus . IN_PROGRESS : \"\ud83d\udd35\" , TypeStatus . COMPLETED : \"\u2705\" , TypeStatus . PAUSED : \"\u25fc\ufe0f\" , TypeStatus . RETRY : \"\u2757\" , TypeStatus . FAILED : \"\u274c\" } return status . get ( value ) NOT_STARTED = 'Not started' class-attribute instance-attribute Status not started. IN_PROGRESS = 'In progress' class-attribute instance-attribute Status in progress. COMPLETED = 'Completed' class-attribute instance-attribute Status completed. PAUSED = 'Paused' class-attribute instance-attribute Status paused. RETRY = 'Retry' class-attribute instance-attribute Status retry. FAILED = 'Failed' class-attribute instance-attribute Status failed.","title":"TypeStatus"},{"location":"nav/reference/type-status/#typestatus","text":"","title":"TypeStatus"},{"location":"nav/reference/type-status/#dotflow.core.types.status.TypeStatus","text":"Import You can import the TypeStatus class with: from dotflow.core.types import TypeStatus Source code in dotflow/core/types/status.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class TypeStatus : \"\"\" Import: You can import the **TypeStatus** class with: from dotflow.core.types import TypeStatus \"\"\" NOT_STARTED : Annotated [ str , Doc ( \"Status not started.\" )] = \"Not started\" IN_PROGRESS : Annotated [ str , Doc ( \"Status in progress.\" )] = \"In progress\" COMPLETED : Annotated [ str , Doc ( \"Status completed.\" )] = \"Completed\" PAUSED : Annotated [ str , Doc ( \"Status paused.\" )] = \"Paused\" RETRY : Annotated [ str , Doc ( \"Status retry.\" )] = \"Retry\" FAILED : Annotated [ str , Doc ( \"Status failed.\" )] = \"Failed\" @classmethod def get_symbol ( cls , value : str ) -> str : status = { TypeStatus . NOT_STARTED : \"\u26aa\" , TypeStatus . IN_PROGRESS : \"\ud83d\udd35\" , TypeStatus . COMPLETED : \"\u2705\" , TypeStatus . PAUSED : \"\u25fc\ufe0f\" , TypeStatus . RETRY : \"\u2757\" , TypeStatus . FAILED : \"\u274c\" } return status . get ( value )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;TypeStatus"},{"location":"nav/reference/type-status/#dotflow.core.types.status.TypeStatus.NOT_STARTED","text":"Status not started.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;NOT_STARTED"},{"location":"nav/reference/type-status/#dotflow.core.types.status.TypeStatus.IN_PROGRESS","text":"Status in progress.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;IN_PROGRESS"},{"location":"nav/reference/type-status/#dotflow.core.types.status.TypeStatus.COMPLETED","text":"Status completed.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;COMPLETED"},{"location":"nav/reference/type-status/#dotflow.core.types.status.TypeStatus.PAUSED","text":"Status paused.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;PAUSED"},{"location":"nav/reference/type-status/#dotflow.core.types.status.TypeStatus.RETRY","text":"Status retry.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;RETRY"},{"location":"nav/reference/type-status/#dotflow.core.types.status.TypeStatus.FAILED","text":"Status failed.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-attribute\"></code>&nbsp;FAILED"},{"location":"nav/reference/utils/","text":"Utils dotflow . utils . basic_functions . basic_function ( * args , ** kwargs ) Source code in dotflow/utils/basic_functions.py 4 5 def basic_function ( * args , ** kwargs ) -> None : pass dotflow . utils . basic_functions . basic_callback ( * args , ** kwargs ) Source code in dotflow/utils/basic_functions.py 8 9 def basic_callback ( * args , ** kwargs ) -> None : pass","title":"Utils"},{"location":"nav/reference/utils/#utils","text":"","title":"Utils"},{"location":"nav/reference/utils/#dotflow.utils.basic_functions.basic_function","text":"Source code in dotflow/utils/basic_functions.py 4 5 def basic_function ( * args , ** kwargs ) -> None : pass","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-function\"></code>&nbsp;basic_function"},{"location":"nav/reference/utils/#dotflow.utils.basic_functions.basic_callback","text":"Source code in dotflow/utils/basic_functions.py 8 9 def basic_callback ( * args , ** kwargs ) -> None : pass","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-function\"></code>&nbsp;basic_callback"},{"location":"nav/reference/workflow/","text":"Manager dotflow.core.workflow.Manager Import You can import the Manager class with: from dotflow.core.workflow import Manager Example class dotflow.core.workflow.Manager workflow = Manager( tasks=[tasks], on_success=basic_callback, on_failure=basic_callback, keep_going=True ) Parameters: Name Type Description Default tasks List [ Task ] A list containing objects of type Task. required on_success Callable Success function to be executed after the completion of the entire workflow. It's essentially a callback for successful scenarios. basic_callback on_failure Callable Failure function to be executed after the completion of the entire workflow. It's essentially a callback for error scenarios basic_callback mode TypeExecution Parameter that defines the execution mode of the workflow. Currently, there are options to execute in sequential , background , or parallel mode. The sequential mode is used by default. SEQUENTIAL keep_going bool A parameter that receives a boolean object with the purpose of continuing or not the execution of the workflow in case of an error during the execution of a task. If it is true , the execution will continue; if it is False , the workflow will stop. False workflow_id UUID Workflow ID. None Attributes: Name Type Description on_success Callable on_failure Callable workflow_id UUID started datetime Source code in dotflow/core/workflow.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 class Manager : \"\"\" Import: You can import the **Manager** class with: from dotflow.core.workflow import Manager Example: `class` dotflow.core.workflow.Manager workflow = Manager( tasks=[tasks], on_success=basic_callback, on_failure=basic_callback, keep_going=True ) Args: tasks (List[Task]): A list containing objects of type Task. on_success (Callable): Success function to be executed after the completion of the entire workflow. It's essentially a callback for successful scenarios. on_failure (Callable): Failure function to be executed after the completion of the entire workflow. It's essentially a callback for error scenarios mode (TypeExecution): Parameter that defines the execution mode of the workflow. Currently, there are options to execute in **sequential**, **background**, or **parallel** mode. The sequential mode is used by default. keep_going (bool): A parameter that receives a boolean object with the purpose of continuing or not the execution of the workflow in case of an error during the execution of a task. If it is **true**, the execution will continue; if it is **False**, the workflow will stop. workflow_id (UUID): Workflow ID. Attributes: on_success (Callable): on_failure (Callable): workflow_id (UUID): started (datetime): \"\"\" def __init__ ( self , tasks : List [ Task ], on_success : Callable = basic_callback , on_failure : Callable = basic_callback , mode : TypeExecution = TypeExecution . SEQUENTIAL , keep_going : bool = False , workflow_id : UUID = None , ) -> None : self . tasks = tasks self . on_success = on_success self . on_failure = on_failure self . workflow_id = workflow_id or uuid4 () self . started = datetime . now () execution = None groups = grouper ( tasks = tasks ) try : execution = getattr ( self , mode ) except AttributeError as err : raise ExecutionModeNotExist () from err self . tasks = execution ( tasks = tasks , workflow_id = workflow_id , ignore = keep_going , groups = groups ) self . _callback_workflow ( tasks = self . tasks ) def _callback_workflow ( self , tasks : List [ Task ]): final_status = [ task . status for task in tasks ] if TypeStatus . FAILED in final_status : self . on_failure ( tasks = tasks ) else : self . on_success ( tasks = tasks ) def sequential ( self , ** kwargs ) -> List [ Task ]: if len ( kwargs . get ( \"groups\" , {})) > 1 and not is_darwin (): process = SequentialGroup ( ** kwargs ) return process . get_tasks () process = Sequential ( ** kwargs ) return process . get_tasks () def sequential_group ( self , ** kwargs ): process = SequentialGroup ( ** kwargs ) return process . get_tasks () def background ( self , ** kwargs ) -> List [ Task ]: process = Background ( ** kwargs ) return process . get_tasks () def parallel ( self , ** kwargs ) -> List [ Task ]: if is_darwin (): warnings . warn ( \"Parallel mode does not work with MacOS.\" \" Running tasks in sequence.\" , Warning ) process = Sequential ( ** kwargs ) return process . get_tasks () process = Parallel ( ** kwargs ) return process . get_tasks () _callback_workflow ( tasks ) Source code in dotflow/core/workflow.py 120 121 122 123 124 125 126 def _callback_workflow ( self , tasks : List [ Task ]): final_status = [ task . status for task in tasks ] if TypeStatus . FAILED in final_status : self . on_failure ( tasks = tasks ) else : self . on_success ( tasks = tasks ) sequential ( ** kwargs ) Source code in dotflow/core/workflow.py 128 129 130 131 132 133 134 def sequential ( self , ** kwargs ) -> List [ Task ]: if len ( kwargs . get ( \"groups\" , {})) > 1 and not is_darwin (): process = SequentialGroup ( ** kwargs ) return process . get_tasks () process = Sequential ( ** kwargs ) return process . get_tasks () background ( ** kwargs ) Source code in dotflow/core/workflow.py 140 141 142 def background ( self , ** kwargs ) -> List [ Task ]: process = Background ( ** kwargs ) return process . get_tasks () parallel ( ** kwargs ) Source code in dotflow/core/workflow.py 144 145 146 147 148 149 150 151 152 153 154 155 def parallel ( self , ** kwargs ) -> List [ Task ]: if is_darwin (): warnings . warn ( \"Parallel mode does not work with MacOS.\" \" Running tasks in sequence.\" , Warning ) process = Sequential ( ** kwargs ) return process . get_tasks () process = Parallel ( ** kwargs ) return process . get_tasks ()","title":"Manager"},{"location":"nav/reference/workflow/#manager","text":"","title":"Manager"},{"location":"nav/reference/workflow/#dotflow.core.workflow.Manager","text":"Import You can import the Manager class with: from dotflow.core.workflow import Manager Example class dotflow.core.workflow.Manager workflow = Manager( tasks=[tasks], on_success=basic_callback, on_failure=basic_callback, keep_going=True ) Parameters: Name Type Description Default tasks List [ Task ] A list containing objects of type Task. required on_success Callable Success function to be executed after the completion of the entire workflow. It's essentially a callback for successful scenarios. basic_callback on_failure Callable Failure function to be executed after the completion of the entire workflow. It's essentially a callback for error scenarios basic_callback mode TypeExecution Parameter that defines the execution mode of the workflow. Currently, there are options to execute in sequential , background , or parallel mode. The sequential mode is used by default. SEQUENTIAL keep_going bool A parameter that receives a boolean object with the purpose of continuing or not the execution of the workflow in case of an error during the execution of a task. If it is true , the execution will continue; if it is False , the workflow will stop. False workflow_id UUID Workflow ID. None Attributes: Name Type Description on_success Callable on_failure Callable workflow_id UUID started datetime Source code in dotflow/core/workflow.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 class Manager : \"\"\" Import: You can import the **Manager** class with: from dotflow.core.workflow import Manager Example: `class` dotflow.core.workflow.Manager workflow = Manager( tasks=[tasks], on_success=basic_callback, on_failure=basic_callback, keep_going=True ) Args: tasks (List[Task]): A list containing objects of type Task. on_success (Callable): Success function to be executed after the completion of the entire workflow. It's essentially a callback for successful scenarios. on_failure (Callable): Failure function to be executed after the completion of the entire workflow. It's essentially a callback for error scenarios mode (TypeExecution): Parameter that defines the execution mode of the workflow. Currently, there are options to execute in **sequential**, **background**, or **parallel** mode. The sequential mode is used by default. keep_going (bool): A parameter that receives a boolean object with the purpose of continuing or not the execution of the workflow in case of an error during the execution of a task. If it is **true**, the execution will continue; if it is **False**, the workflow will stop. workflow_id (UUID): Workflow ID. Attributes: on_success (Callable): on_failure (Callable): workflow_id (UUID): started (datetime): \"\"\" def __init__ ( self , tasks : List [ Task ], on_success : Callable = basic_callback , on_failure : Callable = basic_callback , mode : TypeExecution = TypeExecution . SEQUENTIAL , keep_going : bool = False , workflow_id : UUID = None , ) -> None : self . tasks = tasks self . on_success = on_success self . on_failure = on_failure self . workflow_id = workflow_id or uuid4 () self . started = datetime . now () execution = None groups = grouper ( tasks = tasks ) try : execution = getattr ( self , mode ) except AttributeError as err : raise ExecutionModeNotExist () from err self . tasks = execution ( tasks = tasks , workflow_id = workflow_id , ignore = keep_going , groups = groups ) self . _callback_workflow ( tasks = self . tasks ) def _callback_workflow ( self , tasks : List [ Task ]): final_status = [ task . status for task in tasks ] if TypeStatus . FAILED in final_status : self . on_failure ( tasks = tasks ) else : self . on_success ( tasks = tasks ) def sequential ( self , ** kwargs ) -> List [ Task ]: if len ( kwargs . get ( \"groups\" , {})) > 1 and not is_darwin (): process = SequentialGroup ( ** kwargs ) return process . get_tasks () process = Sequential ( ** kwargs ) return process . get_tasks () def sequential_group ( self , ** kwargs ): process = SequentialGroup ( ** kwargs ) return process . get_tasks () def background ( self , ** kwargs ) -> List [ Task ]: process = Background ( ** kwargs ) return process . get_tasks () def parallel ( self , ** kwargs ) -> List [ Task ]: if is_darwin (): warnings . warn ( \"Parallel mode does not work with MacOS.\" \" Running tasks in sequence.\" , Warning ) process = Sequential ( ** kwargs ) return process . get_tasks () process = Parallel ( ** kwargs ) return process . get_tasks ()","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;Manager"},{"location":"nav/reference/workflow/#dotflow.core.workflow.Manager._callback_workflow","text":"Source code in dotflow/core/workflow.py 120 121 122 123 124 125 126 def _callback_workflow ( self , tasks : List [ Task ]): final_status = [ task . status for task in tasks ] if TypeStatus . FAILED in final_status : self . on_failure ( tasks = tasks ) else : self . on_success ( tasks = tasks )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;_callback_workflow"},{"location":"nav/reference/workflow/#dotflow.core.workflow.Manager.sequential","text":"Source code in dotflow/core/workflow.py 128 129 130 131 132 133 134 def sequential ( self , ** kwargs ) -> List [ Task ]: if len ( kwargs . get ( \"groups\" , {})) > 1 and not is_darwin (): process = SequentialGroup ( ** kwargs ) return process . get_tasks () process = Sequential ( ** kwargs ) return process . get_tasks ()","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;sequential"},{"location":"nav/reference/workflow/#dotflow.core.workflow.Manager.background","text":"Source code in dotflow/core/workflow.py 140 141 142 def background ( self , ** kwargs ) -> List [ Task ]: process = Background ( ** kwargs ) return process . get_tasks ()","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;background"},{"location":"nav/reference/workflow/#dotflow.core.workflow.Manager.parallel","text":"Source code in dotflow/core/workflow.py 144 145 146 147 148 149 150 151 152 153 154 155 def parallel ( self , ** kwargs ) -> List [ Task ]: if is_darwin (): warnings . warn ( \"Parallel mode does not work with MacOS.\" \" Running tasks in sequence.\" , Warning ) process = Sequential ( ** kwargs ) return process . get_tasks () process = Parallel ( ** kwargs ) return process . get_tasks ()","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;parallel"}]}