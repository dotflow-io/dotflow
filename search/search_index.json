{"config":{"lang":["en","pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to dotflow","text":"Website   \u00a0\u2022\u00a0   Documentation   \u00a0\u2022\u00a0   Pypi <p>With Dotflow, you get a powerful and easy-to-use library designed to create execution pipelines without complication. Add tasks intuitively and control the entire process with just a few commands.</p> <p>Our goal is to make task management faster and more secure, without overwhelming you with complexity. Simply instantiate the DotFlow class, add your tasks with the <code>add</code> method, and start execution with the <code>start</code> method.</p> <p>Start with the basics here.</p>"},{"location":"#getting-help","title":"Getting Help","text":"<p>We use GitHub issues for tracking bugs and feature requests and have limited bandwidth to address them. If you need anything, I ask you to please follow our templates for opening issues or discussions.</p> <ul> <li>\ud83d\udc1b Bug Report</li> <li>\ud83d\udcd5 Documentation</li> <li>\ud83d\ude80 Feature Request</li> <li>\u26a0\ufe0f Security Issue</li> <li>\ud83d\udcac General Question</li> </ul>"},{"location":"#commit-style","title":"Commit Style","text":"Icon Type Description \u2699\ufe0f FEATURE New feature \ud83d\udcdd PEP8 Formatting fixes following PEP8 \ud83d\udccc ISSUE Reference to issue \ud83e\udeb2 BUG Bug fix \ud83d\udcd8 DOCS Documentation changes \ud83d\udce6 PyPI PyPI releases \u2764\ufe0f\ufe0f TEST Automated tests \u2b06\ufe0f CI/CD Changes in continuous integration/delivery \u26a0\ufe0f SECURITY Security improvements"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT License.</p>"},{"location":"nav/advanced/notify-with-telegram/","title":"Notify with Telegram","text":""},{"location":"nav/advanced/notify-with-telegram/#bot-telegram","title":"Bot Telegram","text":""},{"location":"nav/advanced/notify-with-telegram/#create-a-bot-on-telegram","title":"Create a bot on Telegram:","text":"<p>1 - Open the Telegram app on your mobile device.</p> <p>2 - Tap the search icon and look for BotFather.</p> <p>3 - Open the contact and type <code>/newbot</code>.</p> <p>4 - Enter a name for your bot.</p>"},{"location":"nav/advanced/notify-with-telegram/#generate-bot-token","title":"Generate Bot Token:","text":"<p>1 - Type the command <code>/token</code>.</p> <p>2 - Select the bot you just created from the list.</p> <p>3 - BotFather will return an access token \u2014 copy and save this token securely. It will be required to authenticate your bot.</p>"},{"location":"nav/advanced/notify-with-telegram/#retrieving-your-telegram-chat-id","title":"Retrieving Your Telegram Chat ID","text":"<p>1 - Send a message to your bot in Telegram to ensure it appears in the bot's update log.</p> <p>2 - Run the following <code>curl</code> command to fetch the latest updates from your bot:</p> <pre><code>curl --location --globoff 'https://api.telegram.org/bot&lt;YOUR_BOT_TOKEN&gt;/getUpdates'\n</code></pre> <p>Replace <code>&lt;YOUR_BOT_TOKEN&gt;</code> with the token provided by BotFather.</p> <p>3 - Inspect the API response, and locate the following key <code>result[0].channel_post.chat.id</code>. This is your chat ID.</p> <p>4 - Copy and store the chat ID in a secure location. You will need it to configure the <code>NotifyTelegram</code> instance.</p>"},{"location":"nav/advanced/notify-with-telegram/#dotflow-config","title":"DotFlow Config","text":""},{"location":"nav/advanced/notify-with-telegram/#import","title":"Import","text":"<p>Start with the basics, which is importing the necessary classes and methods.</p> <pre><code>import os\n\nfrom dotflow import Config, DotFlow, action\nfrom dotflow.notify import NotifyTelegram\nfrom dotflow.types import TypeStatus\n</code></pre>"},{"location":"nav/advanced/notify-with-telegram/#task-function","title":"Task function","text":"<p>Use the <code>@action</code> decorator to define a simple task that will be executed in the workflow:</p> <pre><code>@action\ndef simple_task():\n    return \"ok\"\n</code></pre>"},{"location":"nav/advanced/notify-with-telegram/#notify-class","title":"Notify Class","text":"<p>Instantiate the <code>NotifyTelegram</code> class with your Telegram bot credentials. You can use environment variables for security:</p> <pre><code>notify = NotifyTelegram(\n    token=os.getenv(\"TOKEN\"),\n    chat_id=os.getenv(\"CHAT_ID\"),\n    notification_type=TypeStatus.FAILED  # Notify only on failure\n)\n</code></pre>"},{"location":"nav/advanced/notify-with-telegram/#dotflow-class","title":"Dotflow Class","text":"<p>Pass the <code>notify</code> instance into the <code>Config</code> class and initialize the <code>DotFlow</code> workflow:</p> <pre><code>workflow = DotFlow(\n    config=Config(notify=notify)\n)\n</code></pre>"},{"location":"nav/advanced/notify-with-telegram/#add-task","title":"Add Task","text":"<p>Add your defined task as a step in the workflow:</p> <pre><code>workflow.task.add(step=simple_task)\n</code></pre>"},{"location":"nav/advanced/notify-with-telegram/#start","title":"Start","text":"<p>Start the workflow execution:</p> <pre><code>workflow.start()\n</code></pre>"},{"location":"nav/development/development-guide/","title":"Development Guide","text":""},{"location":"nav/development/development-guide/#getting-help","title":"Getting Help","text":"<p>We use GitHub issues for tracking bugs and feature requests and have limited bandwidth to address them. If you need anything, I ask you to please follow our templates for opening issues or discussions.</p> <ul> <li>\ud83d\udc1b Bug Report</li> <li>\ud83d\udcd5 Documentation</li> <li>\ud83d\ude80 Feature Request</li> <li>\ud83d\udcac General Question</li> </ul>"},{"location":"nav/development/development-guide/#commit-style","title":"Commit Style","text":"Icon Type Description \u2699\ufe0f FEATURE New feature \ud83d\udcdd PEP8 Formatting fixes following PEP8 \ud83d\udccc ISSUE Reference to issue \ud83e\udeb2 BUG Bug fix \ud83d\udcd8 DOCS Documentation changes \ud83d\udce6 PyPI PyPI releases \u2764\ufe0f\ufe0f TEST Automated tests \u2b06\ufe0f CI/CD Changes in continuous integration/delivery \u26a0\ufe0f SECURITY Security improvements"},{"location":"nav/development/release-notes/","title":"Release Notes","text":""},{"location":"nav/development/release-notes/#v0131","title":"v0.13.1","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.13.1</li> <li>\u26a0\ufe0f Update dependencies</li> </ul>"},{"location":"nav/development/release-notes/#v0130","title":"v0.13.0","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.13.0</li> <li>\ud83d\udccc Action with timeout, retry_delay and backoff</li> <li>\ud83d\udccc Notification with Telegram</li> </ul>"},{"location":"nav/development/release-notes/#v0120","title":"v0.12.0","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.12.0</li> <li>\ud83d\udccc Separate tasks into groups</li> <li>\ud83d\udccc Workflow result</li> </ul>"},{"location":"nav/development/release-notes/#v0111","title":"v0.11.1","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.11.1</li> <li>\ud83e\udeb2 BUG: Problem with context of type 'pydantic class'</li> </ul>"},{"location":"nav/development/release-notes/#v0110","title":"v0.11.0","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.11.0</li> </ul>"},{"location":"nav/development/release-notes/#v0100","title":"v0.10.0","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.10.0</li> <li>\ud83d\udccc Storage MongoDB</li> <li>\ud83d\udccc ABC Config / Storage</li> <li>\ud83d\udccc Update Documentation</li> </ul>"},{"location":"nav/development/release-notes/#v091","title":"v0.9.1","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.9.1</li> <li>\ud83e\udeb2 BUG: Fixed ImportError NoneType Python 3.9</li> </ul>"},{"location":"nav/development/release-notes/#v090","title":"v0.9.0","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.9.0</li> <li>\ud83d\udccc Bulk task inclusion option</li> </ul>"},{"location":"nav/development/release-notes/#v082","title":"v0.8.2","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.8.2</li> <li>\ud83e\udeb2 Fixed class-type step without init</li> </ul>"},{"location":"nav/development/release-notes/#v081","title":"v0.8.1","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.8.1</li> <li>\ud83e\udeb2 Fixed context switching</li> </ul>"},{"location":"nav/development/release-notes/#v080","title":"v0.8.0","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.8.0</li> <li>\ud83d\udccc Create CLI to manage workflow</li> </ul>"},{"location":"nav/development/release-notes/#v070","title":"v0.7.0","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.7.0</li> <li>\ud83d\udccc Communication layer implementation</li> </ul>"},{"location":"nav/development/release-notes/#v060","title":"v0.6.0","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.6.0</li> </ul>"},{"location":"nav/development/release-notes/#v050","title":"v0.5.0","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.5.1</li> <li>\ud83d\udccc CLI - Command-Line Interface</li> <li>\ud83d\udccc Step adaptation with class structure</li> </ul>"},{"location":"nav/development/release-notes/#v041","title":"v0.4.1","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.4.1</li> </ul>"},{"location":"nav/development/release-notes/#v040","title":"v0.4.0","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.4.0</li> <li>\ud83d\udccc Improvement of the API to start the workflow task</li> <li>\ud83d\udccc Improved API interface for decorators</li> <li>\ud83d\udccc Improvement unit tests</li> </ul>"},{"location":"nav/development/release-notes/#v030","title":"v0.3.0","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.3.0</li> <li>\ud83d\udccc Improvement of the API to start the workflow task</li> </ul>"},{"location":"nav/development/release-notes/#v020","title":"v0.2.0","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.2.0</li> <li>\ud83d\udccc Create documentation</li> <li>\ud83d\udccc Import of the context class</li> </ul>"},{"location":"nav/development/release-notes/#v010","title":"v0.1.0","text":"<ul> <li>\ud83d\udce6 PyPI - Build 0.1.0</li> </ul>"},{"location":"nav/learn/","title":"Learn","text":"<p>Here are the introductory sections and the tutorials to learn Dotflow.</p>"},{"location":"nav/learn/cli/","title":"Dotflow CLI","text":"<p>The Dotflow CLI (Command-Line Interface) is a feature that simplifies the execution of workflows in environments that require running through terminal commands.</p>"},{"location":"nav/learn/cli/#simple-start","title":"Simple Start","text":"<pre><code>dotflow start --step examples.cli_with_mode.simple_step\n</code></pre>"},{"location":"nav/learn/cli/#with-initial-context","title":"With Initial Context","text":"<pre><code>dotflow start --step examples.cli_with_initial_context.simple_step --initial-context abc\n</code></pre>"},{"location":"nav/learn/cli/#with-callback","title":"With Callback","text":"<pre><code>dotflow start --step examples.cli_with_callback.simple_step --callback examples.cli_with_callback.callback\n</code></pre>"},{"location":"nav/learn/cli/#with-mode","title":"With Mode","text":"<pre><code>dotflow start --step examples.cli_with_mode.simple_step --mode sequential\n</code></pre> <pre><code>dotflow start --step examples.cli_with_mode.simple_step --mode background\n</code></pre> <pre><code>dotflow start --step examples.cli_with_mode.simple_step --mode parallel\n</code></pre>"},{"location":"nav/learn/concept-of-context/","title":"Concept of Context","text":"<p>When referring to Context within the Dotflow library, we are talking about how data is transferred within tasks. The Context is essentially a class embedded in every task return. This class is standardized, and you can access its value through the <code>storage</code> object.</p> <p>Note</p> <p>The Context class pattern is applied to the Initial Context and the Previous Context of a task.</p>"},{"location":"nav/learn/concept-of-context/#accessing-context-data","title":"Accessing context data","text":"Python 3.8+ <pre><code>from dotflow import Context\n\nnew_context = Context(\n    storage={\"data\": [0, 1, 2, 3]}\n)\n\nprint(new_context.time)\nprint(new_context.task_id)\nprint(new_context.workflow_id)\nprint(new_context.storage)\n</code></pre> <p>For implementation details of the class, you can access them here</p>"},{"location":"nav/learn/examples/","title":"Examples","text":"<p>Github: dotflow/examples</p> Example Command cli_with_callback <code>dotflow start --step examples.cli_with_callback.simple_step --callback examples.cli_with_callback.callback</code> cli_with_initial_context <code>dotflow start --step examples.cli_with_initial_context.simple_step --initial-context abc</code> cli_with_mode <code>dotflow start --step examples.cli_with_mode.simple_step --mode sequential</code> cli_with_output_context <code>dotflow start --step examples.cli_with_output_context.simple_step --storage file</code> cli_with_path <code>dotflow start --step examples.cli_with_path.simple_step --path .storage --storage file</code> flow <code>python examples/flow.py</code> simple_class_workflow <code>python examples/simple_class_workflow.py</code> simple_cli <code>dotflow start --step examples.simple_cli.simple_step</code> simple_function_workflow <code>python examples/simple_function_workflow.py</code> simple_function_workflow_with_error <code>python examples/simple_function_workflow_with_error.py</code> step_class_result_context <code>python examples/step_class_result_context.py</code> step_class_result_storage <code>python examples/step_class_result_storage.py</code> step_class_result_task <code>python examples/step_class_result_task.py</code> step_function_result_context <code>python examples/step_function_result_context.py</code> step_function_result_storage <code>python examples/step_function_result_storage.py</code> step_function_result_task <code>python examples/step_function_result_task.py</code> step_with_groups <code>python examples/step_with_groups.py</code> step_with_initial_context <code>python examples/step_with_initial_context.py</code> step_with_many_contexts <code>python examples/step_with_many_contexts.py</code> step_with_notify_telegram <code>python examples/step_with_notify_telegram.py</code> step_with_previous_context <code>python examples/step_with_previous_context.py</code> step_with_storage_file <code>python examples/step_with_storage_file.py</code> step_with_storage_mongodb <code>python examples/step_with_storage_mongodb.py</code> workflow_background_mode <code>python examples/workflow_background_mode.py</code> workflow_keep_going_true <code>python examples/workflow_keep_going_true.py</code> workflow_parallel_mode <code>python examples/workflow_parallel_mode.py</code> workflow_sequential_group_mode <code>python examples/workflow_sequential_group_mode.py</code> workflow_sequential_mode <code>python examples/workflow_sequential_mode.py</code> workflow_step_callback <code>python examples/workflow_step_callback.py</code> workflow_with_backoff <code>python examples/workflow_with_backoff.py</code> workflow_with_callback_failure <code>python examples/workflow_with_callback_failure.py</code> workflow_with_callback_success <code>python examples/workflow_with_callback_success.py</code> workflow_with_retry <code>python examples/workflow_with_retry.py</code> workflow_with_retry_delay <code>python examples/workflow_with_retry_delay.py</code> workflow_with_timeout <code>python examples/workflow_with_timeout.py</code>"},{"location":"nav/learn/process-mode-sequential-group/","title":"Sequential Group","text":""},{"location":"nav/learn/process-mode-sequential-group/#implementation","title":"Implementation","text":"Python 3.8+ <pre><code>from time import sleep\n\nfrom dotflow import DotFlow, action\n\n\n@action\ndef task_foo(initial_context):\n    sleep(2)\n    value = initial_context.storage\n    return value * value * value\n\n\n@action\ndef task_bar(initial_context):\n    sleep(1)\n    value = initial_context.storage\n    return value * value * value\n\n\ndef main():\n    workflow = DotFlow()\n\n    workflow.task.add(step=task_foo, initial_context=10, group_name=\"foo\")\n    workflow.task.add(step=task_bar, initial_context=10, group_name=\"bar\")\n\n    workflow.start(mode=\"sequential\")\n\n    return workflow\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"nav/learn/process-mode-sequential-group/#workflow","title":"Workflow","text":"<pre><code>flowchart TD\n    A[Start] --&gt;|run| C(Parallel Groups)\n    C --&gt;|run| D[task_a]\n    C --&gt;|run| E[task_c]\n    D --&gt;|response| X[task_b]\n    X --&gt; H[Finish]\n    E --&gt;|response| Y[task_d]\n    Y --&gt; H[Finish]</code></pre>"},{"location":"nav/learn/process-mode-sequential/","title":"Sequential","text":""},{"location":"nav/learn/process-mode-sequential/#implementation","title":"Implementation","text":"Python 3.8+ <pre><code>from time import sleep\n\nfrom dotflow import DotFlow, action\n\n\n@action\ndef task_foo(initial_context):\n    sleep(2)\n    value = initial_context.storage\n    return value * value * value\n\n\n@action\ndef task_bar(initial_context):\n    sleep(1)\n    value = initial_context.storage\n    return value * value * value\n\n\ndef main():\n    workflow = DotFlow()\n\n    workflow.task.add(step=task_foo, initial_context=10)\n    workflow.task.add(step=task_bar, initial_context=10)\n\n    workflow.start(mode=\"sequential\")\n\n    return workflow\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"nav/learn/process-mode-sequential/#workflow","title":"Workflow","text":"<pre><code>flowchart TD\nA[Start] --&gt;|run| B\nB[task_foo] --&gt;|response to| C\nC[task_bar] --&gt;|response| D\nD[Finish]</code></pre>"},{"location":"nav/reference/abc-flow/","title":"Flow","text":""},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow","title":"<code>dotflow.abc.flow.Flow</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>dotflow/abc/flow.py</code> <pre><code>class Flow(ABC):\n\n    def __init__(\n            self,\n            tasks: List[Task],\n            workflow_id: UUID,\n            ignore: bool,\n            groups: Dict[str, List[Task]]\n    ) -&gt; None:\n        self.queue = None\n        self.tasks = tasks\n        self.workflow_id = workflow_id\n        self.ignore = ignore\n        self.groups = groups\n\n        self.setup_queue()\n        self.run()\n\n    @abstractmethod\n    def setup_queue(self) -&gt; None:\n        self.queue = []\n\n    @abstractmethod\n    def get_tasks(self) -&gt; List[Task]:\n        return self.queue\n\n    @abstractmethod\n    def _flow_callback(self, task: Task) -&gt; None:\n        self.queue.append(task)\n\n    @abstractmethod\n    def run(self) -&gt; None:\n        return None\n</code></pre>"},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.groups","title":"<code>groups = groups</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.ignore","title":"<code>ignore = ignore</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.queue","title":"<code>queue = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.tasks","title":"<code>tasks = tasks</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.workflow_id","title":"<code>workflow_id = workflow_id</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.__init__","title":"<code>__init__(tasks, workflow_id, ignore, groups)</code>","text":"Source code in <code>dotflow/abc/flow.py</code> <pre><code>def __init__(\n        self,\n        tasks: List[Task],\n        workflow_id: UUID,\n        ignore: bool,\n        groups: Dict[str, List[Task]]\n) -&gt; None:\n    self.queue = None\n    self.tasks = tasks\n    self.workflow_id = workflow_id\n    self.ignore = ignore\n    self.groups = groups\n\n    self.setup_queue()\n    self.run()\n</code></pre>"},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.get_tasks","title":"<code>get_tasks()</code>  <code>abstractmethod</code>","text":"Source code in <code>dotflow/abc/flow.py</code> <pre><code>@abstractmethod\ndef get_tasks(self) -&gt; List[Task]:\n    return self.queue\n</code></pre>"},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.run","title":"<code>run()</code>  <code>abstractmethod</code>","text":"Source code in <code>dotflow/abc/flow.py</code> <pre><code>@abstractmethod\ndef run(self) -&gt; None:\n    return None\n</code></pre>"},{"location":"nav/reference/abc-flow/#dotflow.abc.flow.Flow.setup_queue","title":"<code>setup_queue()</code>  <code>abstractmethod</code>","text":"Source code in <code>dotflow/abc/flow.py</code> <pre><code>@abstractmethod\ndef setup_queue(self) -&gt; None:\n    self.queue = []\n</code></pre>"},{"location":"nav/reference/abc-http/","title":"HTTPRequest","text":""},{"location":"nav/reference/abc-http/#dotflow.abc.http.HTTPRequest","title":"<code>dotflow.abc.http.HTTPRequest</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>dotflow/abc/http.py</code> <pre><code>class HTTPRequest(ABC):\n\n    def __init__(self, url: str, context: Callable):\n        self.url = url\n        self.context = context\n\n    @abstractmethod\n    def request(\n        self,\n        method: str,\n        body: dict,\n        params: dict,\n        headers: dict,\n    ) -&gt; None:\n        pass\n</code></pre>"},{"location":"nav/reference/abc-http/#dotflow.abc.http.HTTPRequest.context","title":"<code>context = context</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/abc-http/#dotflow.abc.http.HTTPRequest.url","title":"<code>url = url</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/abc-http/#dotflow.abc.http.HTTPRequest.__init__","title":"<code>__init__(url, context)</code>","text":"Source code in <code>dotflow/abc/http.py</code> <pre><code>def __init__(self, url: str, context: Callable):\n    self.url = url\n    self.context = context\n</code></pre>"},{"location":"nav/reference/abc-http/#dotflow.abc.http.HTTPRequest.request","title":"<code>request(method, body, params, headers)</code>  <code>abstractmethod</code>","text":"Source code in <code>dotflow/abc/http.py</code> <pre><code>@abstractmethod\ndef request(\n    self,\n    method: str,\n    body: dict,\n    params: dict,\n    headers: dict,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"nav/reference/abc-log/","title":"Log","text":""},{"location":"nav/reference/abc-log/#dotflow.abc.log.Log","title":"<code>dotflow.abc.log.Log</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Log</p> Source code in <code>dotflow/abc/log.py</code> <pre><code>class Log(ABC):\n    \"\"\"Log\"\"\"\n\n    @abstractmethod\n    def info(self, task: Any) -&gt; None:\n        \"\"\"Info\"\"\"\n\n    @abstractmethod\n    def error(self, task: Any) -&gt; None:\n        \"\"\"Error\"\"\"\n</code></pre>"},{"location":"nav/reference/abc-log/#dotflow.abc.log.Log.error","title":"<code>error(task)</code>  <code>abstractmethod</code>","text":"<p>Error</p> Source code in <code>dotflow/abc/log.py</code> <pre><code>@abstractmethod\ndef error(self, task: Any) -&gt; None:\n    \"\"\"Error\"\"\"\n</code></pre>"},{"location":"nav/reference/abc-log/#dotflow.abc.log.Log.info","title":"<code>info(task)</code>  <code>abstractmethod</code>","text":"<p>Info</p> Source code in <code>dotflow/abc/log.py</code> <pre><code>@abstractmethod\ndef info(self, task: Any) -&gt; None:\n    \"\"\"Info\"\"\"\n</code></pre>"},{"location":"nav/reference/abc-notify/","title":"Notify","text":""},{"location":"nav/reference/abc-notify/#dotflow.abc.notify.Notify","title":"<code>dotflow.abc.notify.Notify</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Notify</p> Source code in <code>dotflow/abc/notify.py</code> <pre><code>class Notify(ABC):\n    \"\"\"Notify\"\"\"\n\n    @abstractmethod\n    def send(self, task: Any) -&gt; None:\n        \"\"\"Send\"\"\"\n</code></pre>"},{"location":"nav/reference/abc-notify/#dotflow.abc.notify.Notify.send","title":"<code>send(task)</code>  <code>abstractmethod</code>","text":"<p>Send</p> Source code in <code>dotflow/abc/notify.py</code> <pre><code>@abstractmethod\ndef send(self, task: Any) -&gt; None:\n    \"\"\"Send\"\"\"\n</code></pre>"},{"location":"nav/reference/abc-storage/","title":"Storage","text":""},{"location":"nav/reference/abc-storage/#dotflow.abc.storage.Storage","title":"<code>dotflow.abc.storage.Storage</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Storage</p> Source code in <code>dotflow/abc/storage.py</code> <pre><code>class Storage(ABC):\n    \"\"\"Storage\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        pass\n\n    @abstractmethod\n    def post(self, key: str, context: Context) -&gt; None:\n        \"\"\"Post context somewhere\"\"\"\n\n    @abstractmethod\n    def get(self, key: str) -&gt; Context:\n        \"\"\"Get context somewhere\"\"\"\n\n    @abstractmethod\n    def key(self, task: Callable):\n        \"\"\"Function that returns a key to get and post storage\"\"\"\n</code></pre>"},{"location":"nav/reference/abc-storage/#dotflow.abc.storage.Storage.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"Source code in <code>dotflow/abc/storage.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    pass\n</code></pre>"},{"location":"nav/reference/abc-storage/#dotflow.abc.storage.Storage.get","title":"<code>get(key)</code>  <code>abstractmethod</code>","text":"<p>Get context somewhere</p> Source code in <code>dotflow/abc/storage.py</code> <pre><code>@abstractmethod\ndef get(self, key: str) -&gt; Context:\n    \"\"\"Get context somewhere\"\"\"\n</code></pre>"},{"location":"nav/reference/abc-storage/#dotflow.abc.storage.Storage.key","title":"<code>key(task)</code>  <code>abstractmethod</code>","text":"<p>Function that returns a key to get and post storage</p> Source code in <code>dotflow/abc/storage.py</code> <pre><code>@abstractmethod\ndef key(self, task: Callable):\n    \"\"\"Function that returns a key to get and post storage\"\"\"\n</code></pre>"},{"location":"nav/reference/abc-storage/#dotflow.abc.storage.Storage.post","title":"<code>post(key, context)</code>  <code>abstractmethod</code>","text":"<p>Post context somewhere</p> Source code in <code>dotflow/abc/storage.py</code> <pre><code>@abstractmethod\ndef post(self, key: str, context: Context) -&gt; None:\n    \"\"\"Post context somewhere\"\"\"\n</code></pre>"},{"location":"nav/reference/abc-tcp/","title":"TCP","text":""},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPClient","title":"<code>dotflow.abc.tcp.TCPClient</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>dotflow/abc/tcp.py</code> <pre><code>class TCPClient(ABC):\n\n    def __init__(self, url: str):\n        self.url = url\n        self.context = None\n\n    @abstractmethod\n    def sender(self, content: dict) -&gt; None:\n        pass\n</code></pre>"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPClient.context","title":"<code>context = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPClient.url","title":"<code>url = url</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPClient.__init__","title":"<code>__init__(url)</code>","text":"Source code in <code>dotflow/abc/tcp.py</code> <pre><code>def __init__(self, url: str):\n    self.url = url\n    self.context = None\n</code></pre>"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPClient.sender","title":"<code>sender(content)</code>  <code>abstractmethod</code>","text":"Source code in <code>dotflow/abc/tcp.py</code> <pre><code>@abstractmethod\ndef sender(self, content: dict) -&gt; None:\n    pass\n</code></pre>"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPServer","title":"<code>dotflow.abc.tcp.TCPServer</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>dotflow/abc/tcp.py</code> <pre><code>class TCPServer(ABC):\n\n    def __init__(self, url: str, handler: Callable):\n        self.url = url\n        self.handler = handler\n        self.context = None\n\n    @abstractmethod\n    async def receiver(self) -&gt; None:\n        pass\n\n    @abstractmethod\n    async def run(self) -&gt; None:\n        pass\n</code></pre>"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPServer.context","title":"<code>context = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPServer.handler","title":"<code>handler = handler</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPServer.url","title":"<code>url = url</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPServer.__init__","title":"<code>__init__(url, handler)</code>","text":"Source code in <code>dotflow/abc/tcp.py</code> <pre><code>def __init__(self, url: str, handler: Callable):\n    self.url = url\n    self.handler = handler\n    self.context = None\n</code></pre>"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPServer.receiver","title":"<code>receiver()</code>  <code>abstractmethod</code> <code>async</code>","text":"Source code in <code>dotflow/abc/tcp.py</code> <pre><code>@abstractmethod\nasync def receiver(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"nav/reference/abc-tcp/#dotflow.abc.tcp.TCPServer.run","title":"<code>run()</code>  <code>abstractmethod</code> <code>async</code>","text":"Source code in <code>dotflow/abc/tcp.py</code> <pre><code>@abstractmethod\nasync def run(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"nav/reference/action/","title":"Action","text":""},{"location":"nav/reference/action/#dotflow.core.action.Action","title":"<code>dotflow.core.action.Action</code>","text":"<p>               Bases: <code>object</code></p> Import <p>You can import the action decorator directly from dotflow:</p> <pre><code>from dotflow import action\n</code></pre> Example <p><code>class</code> dotflow.core.action.Action</p> <p>Standard</p> <pre><code>@action\ndef my_task():\n    print(\"task\")\n</code></pre> <p>With Retry</p> <pre><code>@action(retry=5)\ndef my_task():\n    print(\"task\")\n</code></pre> <p>With Timeout</p> <pre><code>@action(timeout=60)\ndef my_task():\n    print(\"task\")\n</code></pre> <p>With Retry delay</p> <pre><code>@action(retry=5, retry_delay=5)\ndef my_task():\n    print(\"task\")\n</code></pre> <p>With Backoff</p> <pre><code>@action(retry=5, backoff=True)\ndef my_task():\n    print(\"task\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <code>None</code> <code>task</code> <code>Callable</code> <code>None</code> <code>retry</code> <code>int</code> <p>Number of task retries on on_failure.</p> <code>1</code> <code>timeout</code> <code>int</code> <p>Execution timeout for a task. Duration (in seconds)</p> <code>0</code> <code>retry_delay</code> <code>int</code> <p>Retry delay on task on_failure. Duration (in seconds)</p> <code>1</code> <code>backoff</code> <code>int</code> <p>Exponential backoff</p> <code>False</code> Source code in <code>dotflow/core/action.py</code> <pre><code>class Action(object):\n    \"\"\"\n    Import:\n        You can import the **action** decorator directly from dotflow:\n\n            from dotflow import action\n\n    Example:\n        `class` dotflow.core.action.Action\n\n        Standard\n\n            @action\n            def my_task():\n                print(\"task\")\n\n        With Retry\n\n            @action(retry=5)\n            def my_task():\n                print(\"task\")\n\n\n        With Timeout\n\n            @action(timeout=60)\n            def my_task():\n                print(\"task\")\n\n        With Retry delay\n\n            @action(retry=5, retry_delay=5)\n            def my_task():\n                print(\"task\")\n\n        With Backoff\n\n            @action(retry=5, backoff=True)\n            def my_task():\n                print(\"task\")\n\n    Args:\n        func (Callable):\n\n        task (Callable):\n\n        retry (int): Number of task retries on on_failure.\n\n        timeout (int): Execution timeout for a task. Duration (in seconds)\n\n        retry_delay (int): Retry delay on task on_failure. Duration (in seconds)\n\n        backoff (int): Exponential backoff\n\n    \"\"\"\n\n    def __init__(\n        self,\n        func: Callable = None,\n        task: Callable = None,\n        retry: int = 1,\n        timeout: int = 0,\n        retry_delay: int = 1,\n        backoff: bool = False,\n    ) -&gt; None:\n        self.func = func\n        self.task = task\n        self.retry = retry\n        self.timeout = timeout\n        self.retry_delay = retry_delay\n        self.backoff = backoff\n        self.params = []\n\n    def __call__(self, *args, **kwargs):\n        # With parameters\n        if self.func:\n            self._set_params()\n\n            task = self._get_task(kwargs=kwargs)\n            contexts = self._get_context(kwargs=kwargs)\n\n            if contexts:\n                return Context(\n                    storage=self._run_action(*args, **contexts),\n                    task_id=task.task_id,\n                    workflow_id=task.workflow_id,\n                )\n\n            return Context(\n                storage=self._run_action(*args),\n                task_id=task.task_id,\n                workflow_id=task.workflow_id,\n            )\n\n        # No parameters\n        def action(*_args, **_kwargs):\n            self.func = args[0]\n            self._set_params()\n\n            task = self._get_task(kwargs=_kwargs)\n            contexts = self._get_context(kwargs=_kwargs)\n\n            if contexts:\n                return Context(\n                    storage=self._run_action(*_args, **contexts),\n                    task_id=task.task_id,\n                    workflow_id=task.workflow_id,\n                )\n\n            return Context(\n                storage=self._run_action(*_args),\n                task_id=task.task_id,\n                workflow_id=task.workflow_id,\n            )\n\n        return action\n\n    def _run_action(self, *args, **kwargs):\n        for attempt in range(1, self.retry + 1):\n            try:\n                if self.timeout:\n                    with ThreadPoolExecutor(max_workers=1) as executor:\n                        future = executor.submit(self.func, *args, **kwargs)\n                        return future.result(timeout=self.timeout)\n\n                return self.func(*args, **kwargs)\n\n            except Exception as error:\n                last_exception = error\n\n                if is_execution_with_class_internal_error(error=last_exception):\n                    raise ExecutionWithClassError()\n\n                if attempt == self.retry:\n                    raise last_exception\n\n                sleep(self.retry_delay)\n                if self.backoff:\n                    self.retry_delay *= 2\n\n    def _set_params(self):\n        if isinstance(self.func, FunctionType):\n            self.params = [param for param in self.func.__code__.co_varnames]\n\n        if type(self.func) is type:\n            if hasattr(self.func, \"__init__\"):\n                if hasattr(self.func.__init__, \"__code__\"):\n                    self.params = [\n                        param for param in self.func.__init__.__code__.co_varnames\n                    ]\n\n    def _get_context(self, kwargs: Dict):\n        context = {}\n        if \"initial_context\" in self.params:\n            context[\"initial_context\"] = Context(kwargs.get(\"initial_context\"))\n\n        if \"previous_context\" in self.params:\n            context[\"previous_context\"] = Context(kwargs.get(\"previous_context\"))\n\n        return context\n\n    def _get_task(self, kwargs: Dict):\n        return kwargs.get(\"task\")\n</code></pre>"},{"location":"nav/reference/action/#dotflow.core.action.Action.func","title":"<code>func = func</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/action/#dotflow.core.action.Action.task","title":"<code>task = task</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/action/#dotflow.core.action.Action.retry","title":"<code>retry = retry</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/action/#dotflow.core.action.Action.timeout","title":"<code>timeout = timeout</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/action/#dotflow.core.action.Action.retry_delay","title":"<code>retry_delay = retry_delay</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/action/#dotflow.core.action.Action.backoff","title":"<code>backoff = backoff</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/action/#dotflow.core.action.Action.params","title":"<code>params = []</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/action/#dotflow.core.action.Action._run_action","title":"<code>_run_action(*args, **kwargs)</code>","text":"Source code in <code>dotflow/core/action.py</code> <pre><code>def _run_action(self, *args, **kwargs):\n    for attempt in range(1, self.retry + 1):\n        try:\n            if self.timeout:\n                with ThreadPoolExecutor(max_workers=1) as executor:\n                    future = executor.submit(self.func, *args, **kwargs)\n                    return future.result(timeout=self.timeout)\n\n            return self.func(*args, **kwargs)\n\n        except Exception as error:\n            last_exception = error\n\n            if is_execution_with_class_internal_error(error=last_exception):\n                raise ExecutionWithClassError()\n\n            if attempt == self.retry:\n                raise last_exception\n\n            sleep(self.retry_delay)\n            if self.backoff:\n                self.retry_delay *= 2\n</code></pre>"},{"location":"nav/reference/action/#dotflow.core.action.Action._set_params","title":"<code>_set_params()</code>","text":"Source code in <code>dotflow/core/action.py</code> <pre><code>def _set_params(self):\n    if isinstance(self.func, FunctionType):\n        self.params = [param for param in self.func.__code__.co_varnames]\n\n    if type(self.func) is type:\n        if hasattr(self.func, \"__init__\"):\n            if hasattr(self.func.__init__, \"__code__\"):\n                self.params = [\n                    param for param in self.func.__init__.__code__.co_varnames\n                ]\n</code></pre>"},{"location":"nav/reference/action/#dotflow.core.action.Action._get_context","title":"<code>_get_context(kwargs)</code>","text":"Source code in <code>dotflow/core/action.py</code> <pre><code>def _get_context(self, kwargs: Dict):\n    context = {}\n    if \"initial_context\" in self.params:\n        context[\"initial_context\"] = Context(kwargs.get(\"initial_context\"))\n\n    if \"previous_context\" in self.params:\n        context[\"previous_context\"] = Context(kwargs.get(\"previous_context\"))\n\n    return context\n</code></pre>"},{"location":"nav/reference/action/#dotflow.core.action.Action._get_task","title":"<code>_get_task(kwargs)</code>","text":"Source code in <code>dotflow/core/action.py</code> <pre><code>def _get_task(self, kwargs: Dict):\n    return kwargs.get(\"task\")\n</code></pre>"},{"location":"nav/reference/config/","title":"Config","text":""},{"location":"nav/reference/config/#dotflow.core.config.Config","title":"<code>dotflow.core.config.Config</code>","text":"Import <p>You can import the Config class with:</p> <pre><code>from dotflow import Config\n\nfrom dotflow.providers import (\n    StorageDefault,\n    NotifyDefault,\n    LogDefault\n)\n</code></pre> Example <p><code>class</code> dotflow.core.config.Config</p> <pre><code>config = Config(\n    storage=StorageFile(path=\".output\"),\n    notify=NotifyDefault(),\n    log=LogDefault()\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>Optional[Storage]</code> <p>Type of the storage.</p> <code>StorageDefault()</code> <code>notify</code> <code>Optional[Notify]</code> <p>Type of the notify.</p> <code>NotifyDefault()</code> <code>log</code> <code>Optional[Log]</code> <p>Type of the notify.</p> <code>LogDefault()</code> <p>Attributes:</p> Name Type Description <code>storage</code> <code>Optional[Storage]</code> <code>notify</code> <code>Optional[Notify]</code> <code>log</code> <code>Optional[Log]</code> Source code in <code>dotflow/core/config.py</code> <pre><code>class Config:\n    \"\"\"\n    Import:\n        You can import the **Config** class with:\n\n            from dotflow import Config\n\n            from dotflow.providers import (\n                StorageDefault,\n                NotifyDefault,\n                LogDefault\n            )\n\n    Example:\n        `class` dotflow.core.config.Config\n\n            config = Config(\n                storage=StorageFile(path=\".output\"),\n                notify=NotifyDefault(),\n                log=LogDefault()\n            )\n\n    Args:\n        storage (Optional[Storage]): Type of the storage.\n        notify (Optional[Notify]): Type of the notify.\n        log (Optional[Log]): Type of the notify.\n\n    Attributes:\n        storage (Optional[Storage]):\n        notify (Optional[Notify]):\n        log (Optional[Log]):\n    \"\"\"\n\n    def __init__(\n        self,\n        storage: Optional[Storage] = StorageDefault(),\n        notify: Optional[Notify] = NotifyDefault(),\n        log: Optional[Log] = LogDefault(),\n    ) -&gt; None:\n        self.storage = storage\n        self.notify = notify\n        self.log = log\n</code></pre>"},{"location":"nav/reference/context-instance/","title":"ContextInstance","text":""},{"location":"nav/reference/context-instance/#dotflow.core.context.ContextInstance","title":"<code>dotflow.core.context.ContextInstance</code>","text":"Import <p>You can import the ContextInstance class with:</p> <pre><code>from dotflow.core.context import ContextInstance\n</code></pre> Source code in <code>dotflow/core/context.py</code> <pre><code>class ContextInstance:\n    \"\"\"\n    Import:\n        You can import the **ContextInstance** class with:\n\n            from dotflow.core.context import ContextInstance\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self._time = None\n        self._task_id = None\n        self._workflow_id = None\n        self._storage = None\n</code></pre>"},{"location":"nav/reference/context-instance/#dotflow.core.context.ContextInstance._time","title":"<code>_time = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/context-instance/#dotflow.core.context.ContextInstance._task_id","title":"<code>_task_id = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/context-instance/#dotflow.core.context.ContextInstance._workflow_id","title":"<code>_workflow_id = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/context-instance/#dotflow.core.context.ContextInstance._storage","title":"<code>_storage = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/context/","title":"Context","text":""},{"location":"nav/reference/context/#dotflow.core.context.Context","title":"<code>dotflow.core.context.Context</code>","text":"<p>               Bases: <code>ContextInstance</code></p> Import <p>You can import the Context class directly from dotflow:</p> <pre><code>from dotflow import Context\n</code></pre> Example <p><code>class</code> dotflow.core.context.Context</p> <pre><code>Context(\n    storage={\"data\": [0, 1, 2, 3]}\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>Any</code> <p>Attribute where any type of Python object can be stored.</p> <code>None</code> <code>task_id</code> <code>int</code> <p>Task ID.</p> <code>0</code> <code>workflow_id</code> <code>UUID</code> <p>Workflow ID.</p> <code>None</code> Source code in <code>dotflow/core/context.py</code> <pre><code>class Context(ContextInstance):\n    \"\"\"\n    Import:\n        You can import the Context class directly from dotflow:\n\n            from dotflow import Context\n\n    Example:\n        `class` dotflow.core.context.Context\n\n            Context(\n                storage={\"data\": [0, 1, 2, 3]}\n            )\n\n    Args:\n        storage (Any): Attribute where any type of Python object can be stored.\n\n        task_id (int): Task ID.\n\n        workflow_id (UUID): Workflow ID.\n    \"\"\"\n\n    def __init__(\n            self,\n            storage: Any = None,\n            task_id: int = 0,\n            workflow_id: UUID = None,\n    ) -&gt; None:\n        super().__init__(\n            task_id,\n            storage,\n            task_id,\n            workflow_id\n        )\n        self.time = datetime.now()\n        self.task_id = task_id\n        self.workflow_id = workflow_id\n        self.storage = storage\n\n    @property\n    def time(self):\n        return self._time\n\n    @time.setter\n    def time(self, value: datetime):\n        self._time = value\n\n    @property\n    def task_id(self):\n        return self._task_id\n\n    @task_id.setter\n    def task_id(self, value: int):\n        if isinstance(value, int):\n            self._task_id = value\n\n        if not self.task_id:\n            self._task_id = value\n\n    @property\n    def workflow_id(self):\n        return self._workflow_id\n\n    @workflow_id.setter\n    def workflow_id(self, value: UUID):\n        if isinstance(value, UUID):\n            self._workflow_id = value\n\n    @property\n    def storage(self):\n        return self._storage\n\n    @storage.setter\n    def storage(self, value: Any):\n        if isinstance(value, Context):\n            self._storage = value.storage\n\n            self.time = value.time\n            self.task_id = value.task_id\n            self.workflow_id = value.workflow_id\n        else:\n            self._storage = value\n</code></pre>"},{"location":"nav/reference/context/#dotflow.core.context.Context.time","title":"<code>time</code>  <code>property</code> <code>writable</code>","text":""},{"location":"nav/reference/context/#dotflow.core.context.Context.task_id","title":"<code>task_id</code>  <code>property</code> <code>writable</code>","text":""},{"location":"nav/reference/context/#dotflow.core.context.Context.workflow_id","title":"<code>workflow_id</code>  <code>property</code> <code>writable</code>","text":""},{"location":"nav/reference/context/#dotflow.core.context.Context.storage","title":"<code>storage</code>  <code>property</code> <code>writable</code>","text":""},{"location":"nav/reference/decorators/","title":"Decorators","text":""},{"location":"nav/reference/decorators/#dotflow.core.decorators.time.time","title":"<code>dotflow.core.decorators.time.time(func)</code>","text":"<p>\"Time Decorator</p> Source code in <code>dotflow/core/decorators/time.py</code> <pre><code>def time(func):\n    \"\"\"\"Time Decorator\"\"\"\n    def inside(*args, **kwargs):\n        start = datetime.now()\n        task = func(*args, **kwargs)\n        task.duration = (datetime.now() - start).total_seconds()\n        return task\n    return inside\n</code></pre>"},{"location":"nav/reference/dotflow/","title":"DotFlow","text":""},{"location":"nav/reference/dotflow/#dotflow.core.dotflow.DotFlow","title":"<code>dotflow.core.dotflow.DotFlow</code>","text":"Import <p>You can import the Dotflow class directly from dotflow:</p> <pre><code>from dotflow import DotFlow, Config\nfrom dotflow.providers import StorageFile\n</code></pre> Example <p><code>class</code> dotflow.core.dotflow.Dotflow</p> <pre><code>config = Config(\n    storage=StorageFile()\n)\n\nworkflow = DotFlow(config=config)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[Config]</code> <p>Configuration class.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>workflow_id</code> <code>UUID</code> <code>task</code> <code>List[Task]</code> <code>start</code> <code>Manager</code> Source code in <code>dotflow/core/dotflow.py</code> <pre><code>class DotFlow:\n    \"\"\"\n    Import:\n        You can import the **Dotflow** class directly from dotflow:\n\n            from dotflow import DotFlow, Config\n            from dotflow.providers import StorageFile\n\n    Example:\n        `class` dotflow.core.dotflow.Dotflow\n\n            config = Config(\n                storage=StorageFile()\n            )\n\n            workflow = DotFlow(config=config)\n\n    Args:\n        config (Optional[Config]): Configuration class.\n\n    Attributes:\n        workflow_id (UUID):\n\n        task (List[Task]):\n\n        start (Manager):\n    \"\"\"\n\n    def __init__(\n            self,\n            config: Optional[Config] = None\n    ) -&gt; None:\n        self.workflow_id = uuid4()\n        config = config if config else Config()\n\n        self.task = TaskBuilder(\n            config=config,\n            workflow_id=self.workflow_id\n        )\n\n        self.start = partial(\n            Manager,\n            tasks=self.task.queue,\n            workflow_id=self.workflow_id\n        )\n\n    def result_task(self):\n        \"\"\"\n        Returns:\n            list (List[Task]): Returns a list of Task class.\n        \"\"\"\n        return self.task.queue\n\n    def result_context(self):\n        \"\"\"\n        Returns:\n            list (List[Context]): Returns a list of Context class.\n        \"\"\"\n        return [task.current_context for task in self.task.queue]\n\n    def result_storage(self):\n        \"\"\"\n        Returns:\n            list (List[Any]): Returns a list of assorted objects.\n        \"\"\"\n        return [task.current_context.storage for task in self.task.queue]\n\n    def result(self):\n        return self.task.result()\n</code></pre>"},{"location":"nav/reference/dotflow/#dotflow.core.dotflow.DotFlow.workflow_id","title":"<code>workflow_id = uuid4()</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/dotflow/#dotflow.core.dotflow.DotFlow.task","title":"<code>task = TaskBuilder(config=config, workflow_id=(self.workflow_id))</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/dotflow/#dotflow.core.dotflow.DotFlow.start","title":"<code>start = partial(Manager, tasks=(self.task.queue), workflow_id=(self.workflow_id))</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/dotflow/#dotflow.core.dotflow.DotFlow.result_task","title":"<code>result_task()</code>","text":"<p>Returns:</p> Name Type Description <code>list</code> <code>List[Task]</code> <p>Returns a list of Task class.</p> Source code in <code>dotflow/core/dotflow.py</code> <pre><code>def result_task(self):\n    \"\"\"\n    Returns:\n        list (List[Task]): Returns a list of Task class.\n    \"\"\"\n    return self.task.queue\n</code></pre>"},{"location":"nav/reference/dotflow/#dotflow.core.dotflow.DotFlow.result_context","title":"<code>result_context()</code>","text":"<p>Returns:</p> Name Type Description <code>list</code> <code>List[Context]</code> <p>Returns a list of Context class.</p> Source code in <code>dotflow/core/dotflow.py</code> <pre><code>def result_context(self):\n    \"\"\"\n    Returns:\n        list (List[Context]): Returns a list of Context class.\n    \"\"\"\n    return [task.current_context for task in self.task.queue]\n</code></pre>"},{"location":"nav/reference/dotflow/#dotflow.core.dotflow.DotFlow.result_storage","title":"<code>result_storage()</code>","text":"<p>Returns:</p> Name Type Description <code>list</code> <code>List[Any]</code> <p>Returns a list of assorted objects.</p> Source code in <code>dotflow/core/dotflow.py</code> <pre><code>def result_storage(self):\n    \"\"\"\n    Returns:\n        list (List[Any]): Returns a list of assorted objects.\n    \"\"\"\n    return [task.current_context.storage for task in self.task.queue]\n</code></pre>"},{"location":"nav/reference/exception/","title":"Exception","text":""},{"location":"nav/reference/exception/#dotflow.core.exception.MissingActionDecorator","title":"<code>dotflow.core.exception.MissingActionDecorator</code>","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>dotflow/core/exception.py</code> <pre><code>class MissingActionDecorator(Exception):\n\n    def __init__(self):\n        super(MissingActionDecorator, self).__init__(\n            MESSAGE_MISSING_STEP_DECORATOR\n        )\n</code></pre>"},{"location":"nav/reference/exception/#dotflow.core.exception.MissingActionDecorator.__init__","title":"<code>__init__()</code>","text":"Source code in <code>dotflow/core/exception.py</code> <pre><code>def __init__(self):\n    super(MissingActionDecorator, self).__init__(\n        MESSAGE_MISSING_STEP_DECORATOR\n    )\n</code></pre>"},{"location":"nav/reference/exception/#dotflow.core.exception.ExecutionModeNotExist","title":"<code>dotflow.core.exception.ExecutionModeNotExist</code>","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>dotflow/core/exception.py</code> <pre><code>class ExecutionModeNotExist(Exception):\n\n    def __init__(self):\n        super(ExecutionModeNotExist, self).__init__(\n            MESSAGE_EXECUTION_NOT_EXIST\n        )\n</code></pre>"},{"location":"nav/reference/exception/#dotflow.core.exception.ExecutionModeNotExist.__init__","title":"<code>__init__()</code>","text":"Source code in <code>dotflow/core/exception.py</code> <pre><code>def __init__(self):\n    super(ExecutionModeNotExist, self).__init__(\n        MESSAGE_EXECUTION_NOT_EXIST\n    )\n</code></pre>"},{"location":"nav/reference/exception/#dotflow.core.exception.ImportModuleError","title":"<code>dotflow.core.exception.ImportModuleError</code>","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>dotflow/core/exception.py</code> <pre><code>class ImportModuleError(Exception):\n\n    def __init__(self, module: str):\n        super(ImportModuleError, self).__init__(\n            MESSAGE_IMPORT_MODULE_ERROR.format(\n                module=module\n            )\n        )\n</code></pre>"},{"location":"nav/reference/exception/#dotflow.core.exception.ImportModuleError.__init__","title":"<code>__init__(module)</code>","text":"Source code in <code>dotflow/core/exception.py</code> <pre><code>def __init__(self, module: str):\n    super(ImportModuleError, self).__init__(\n        MESSAGE_IMPORT_MODULE_ERROR.format(\n            module=module\n        )\n    )\n</code></pre>"},{"location":"nav/reference/exception/#dotflow.core.exception.NotCallableObject","title":"<code>dotflow.core.exception.NotCallableObject</code>","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>dotflow/core/exception.py</code> <pre><code>class NotCallableObject(Exception):\n\n    def __init__(self, name: str):\n        super(NotCallableObject, self).__init__(\n            MESSAGE_NOT_CALLABLE_OBJECT.format(\n                name=name\n            )\n        )\n</code></pre>"},{"location":"nav/reference/exception/#dotflow.core.exception.NotCallableObject.__init__","title":"<code>__init__(name)</code>","text":"Source code in <code>dotflow/core/exception.py</code> <pre><code>def __init__(self, name: str):\n    super(NotCallableObject, self).__init__(\n        MESSAGE_NOT_CALLABLE_OBJECT.format(\n            name=name\n        )\n    )\n</code></pre>"},{"location":"nav/reference/exception/#dotflow.core.exception.ProblemOrdering","title":"<code>dotflow.core.exception.ProblemOrdering</code>","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>dotflow/core/exception.py</code> <pre><code>class ProblemOrdering(Exception):\n\n    def __init__(self, name: str):\n        super(ProblemOrdering, self).__init__(\n            MESSAGE_PROBLEM_ORDERING.format(\n                name=name\n            )\n        )\n</code></pre>"},{"location":"nav/reference/exception/#dotflow.core.exception.ProblemOrdering.__init__","title":"<code>__init__(name)</code>","text":"Source code in <code>dotflow/core/exception.py</code> <pre><code>def __init__(self, name: str):\n    super(ProblemOrdering, self).__init__(\n        MESSAGE_PROBLEM_ORDERING.format(\n            name=name\n        )\n    )\n</code></pre>"},{"location":"nav/reference/log-default/","title":"LogDefault","text":""},{"location":"nav/reference/log-default/#dotflow.providers.log_default.LogDefault","title":"<code>dotflow.providers.log_default.LogDefault</code>","text":"<p>               Bases: <code>Log</code></p> Source code in <code>dotflow/providers/log_default.py</code> <pre><code>class LogDefault(Log):\n\n    def info(self, task: Any) -&gt; None:\n        logger.info(\n            \"ID %s - %s - %s\",\n            task.workflow_id,\n            task.task_id,\n            task.status,\n        )\n\n    def error(self, task: Any) -&gt; None:\n        logger.error(\n            \"ID %s - %s - %s \\n %s\",\n            task.workflow_id,\n            task.task_id,\n            task.status,\n            task.error.traceback,\n        )\n        console = Console()\n        console.print_exception(show_locals=True)\n</code></pre>"},{"location":"nav/reference/log-default/#dotflow.providers.log_default.LogDefault.error","title":"<code>error(task)</code>","text":"Source code in <code>dotflow/providers/log_default.py</code> <pre><code>def error(self, task: Any) -&gt; None:\n    logger.error(\n        \"ID %s - %s - %s \\n %s\",\n        task.workflow_id,\n        task.task_id,\n        task.status,\n        task.error.traceback,\n    )\n    console = Console()\n    console.print_exception(show_locals=True)\n</code></pre>"},{"location":"nav/reference/log-default/#dotflow.providers.log_default.LogDefault.info","title":"<code>info(task)</code>","text":"Source code in <code>dotflow/providers/log_default.py</code> <pre><code>def info(self, task: Any) -&gt; None:\n    logger.info(\n        \"ID %s - %s - %s\",\n        task.workflow_id,\n        task.task_id,\n        task.status,\n    )\n</code></pre>"},{"location":"nav/reference/notify-default/","title":"NotifyTelegram","text":""},{"location":"nav/reference/notify-default/#dotflow.providers.notify_default.NotifyDefault","title":"<code>dotflow.providers.notify_default.NotifyDefault</code>","text":"<p>               Bases: <code>Notify</code></p> Source code in <code>dotflow/providers/notify_default.py</code> <pre><code>class NotifyDefault(Notify):\n\n    def send(self, task: Any) -&gt; None:\n        pass\n</code></pre>"},{"location":"nav/reference/notify-default/#dotflow.providers.notify_default.NotifyDefault.send","title":"<code>send(task)</code>","text":"Source code in <code>dotflow/providers/notify_default.py</code> <pre><code>def send(self, task: Any) -&gt; None:\n    pass\n</code></pre>"},{"location":"nav/reference/notify-telegram/","title":"NotifyTelegram","text":""},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram","title":"<code>dotflow.providers.notify_telegram.NotifyTelegram</code>","text":"<p>               Bases: <code>Notify</code></p> Source code in <code>dotflow/providers/notify_telegram.py</code> <pre><code>class NotifyTelegram(Notify):\n\n    MESSAGE = \"{symbol} {status}\\n```json\\n{task}```\\n{workflow_id}-{task_id}\"\n    API_TELEGRAM = \"https://api.telegram.org/bot{token}/sendMessage\"\n\n    def __init__(\n        self,\n        token: str,\n        chat_id: int,\n        notification_type: Optional[TypeStatus] = None,\n        timeout: int = 1.5\n    ):\n        self.token = token\n        self.chat_id = chat_id\n        self.notification_type = notification_type\n        self.timeout = timeout\n\n    def send(self, task: Any) -&gt; None:\n        if not self.notification_type or self.notification_type == task.status:\n            data = {\n                \"chat_id\": self.chat_id,\n                \"text\": self._get_text(task=task),\n                \"parse_mode\": \"markdown\",\n            }\n            try:\n                response = post(\n                    url=self.API_TELEGRAM.format(token=self.token),\n                    headers={\"Content-Type\": \"application/json\"},\n                    data=dumps(data),\n                    timeout=self.timeout\n                )\n                response.raise_for_status()\n            except Exception as error:\n                logger.error(\n                    \"Internal problem sending notification on Telegram: %s\",\n                    str(error),\n                )\n\n    def _get_text(self, task: Any) -&gt; str:\n        return self.MESSAGE.format(\n            symbol=TypeStatus.get_symbol(task.status),\n            status=task.status,\n            workflow_id=task.workflow_id,\n            task_id=task.task_id,\n            task=task.result(max=4000),\n        )\n</code></pre>"},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.API_TELEGRAM","title":"<code>API_TELEGRAM = 'https://api.telegram.org/bot{token}/sendMessage'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.MESSAGE","title":"<code>MESSAGE = '{symbol} {status}\\n```json\\n{task}```\\n{workflow_id}-{task_id}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.chat_id","title":"<code>chat_id = chat_id</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.notification_type","title":"<code>notification_type = notification_type</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.timeout","title":"<code>timeout = timeout</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.token","title":"<code>token = token</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.__init__","title":"<code>__init__(token, chat_id, notification_type=None, timeout=1.5)</code>","text":"Source code in <code>dotflow/providers/notify_telegram.py</code> <pre><code>def __init__(\n    self,\n    token: str,\n    chat_id: int,\n    notification_type: Optional[TypeStatus] = None,\n    timeout: int = 1.5\n):\n    self.token = token\n    self.chat_id = chat_id\n    self.notification_type = notification_type\n    self.timeout = timeout\n</code></pre>"},{"location":"nav/reference/notify-telegram/#dotflow.providers.notify_telegram.NotifyTelegram.send","title":"<code>send(task)</code>","text":"Source code in <code>dotflow/providers/notify_telegram.py</code> <pre><code>def send(self, task: Any) -&gt; None:\n    if not self.notification_type or self.notification_type == task.status:\n        data = {\n            \"chat_id\": self.chat_id,\n            \"text\": self._get_text(task=task),\n            \"parse_mode\": \"markdown\",\n        }\n        try:\n            response = post(\n                url=self.API_TELEGRAM.format(token=self.token),\n                headers={\"Content-Type\": \"application/json\"},\n                data=dumps(data),\n                timeout=self.timeout\n            )\n            response.raise_for_status()\n        except Exception as error:\n            logger.error(\n                \"Internal problem sending notification on Telegram: %s\",\n                str(error),\n            )\n</code></pre>"},{"location":"nav/reference/settings/","title":"Settings","text":""},{"location":"nav/reference/settings/#dotflow.settings.Settings","title":"<code>dotflow.settings.Settings</code>","text":"<p>Settings DotFlow</p> Source code in <code>dotflow/settings.py</code> <pre><code>class Settings:\n    \"\"\"Settings DotFlow\"\"\"\n\n    START_PATH = Path(\".output\")\n    GITIGNORE = Path(\".gitignore\")\n\n    LOG_PROFILE = \"dotflow\"\n    LOG_FILE_NAME = Path(\"flow.log\")\n    LOG_PATH = Path(\".output/flow.log\")\n    LOG_FORMAT = \"%(asctime)s - %(levelname)s [%(name)s]: %(message)s\"\n\n    ICON = \":game_die:\"\n    ERROR_ALERT = f\"{ICON} [bold red]Error:[/bold red]\"\n    INFO_ALERT = f\"{ICON} [bold blue]Info:[/bold blue]\"\n    WARNING_ALERT = f\"{ICON} [bold yellow]Warning:[/bold yellow]\"\n</code></pre>"},{"location":"nav/reference/settings/#dotflow.settings.Settings.START_PATH","title":"<code>START_PATH = Path('.output')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nav/reference/settings/#dotflow.settings.Settings.GITIGNORE","title":"<code>GITIGNORE = Path('.gitignore')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nav/reference/settings/#dotflow.settings.Settings.LOG_PROFILE","title":"<code>LOG_PROFILE = 'dotflow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nav/reference/settings/#dotflow.settings.Settings.LOG_FILE_NAME","title":"<code>LOG_FILE_NAME = Path('flow.log')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nav/reference/settings/#dotflow.settings.Settings.LOG_PATH","title":"<code>LOG_PATH = Path('.output/flow.log')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nav/reference/settings/#dotflow.settings.Settings.LOG_FORMAT","title":"<code>LOG_FORMAT = '%(asctime)s - %(levelname)s [%(name)s]: %(message)s'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nav/reference/settings/#dotflow.settings.Settings.ICON","title":"<code>ICON = ':game_die:'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nav/reference/settings/#dotflow.settings.Settings.ERROR_ALERT","title":"<code>ERROR_ALERT = f'{ICON} [bold red]Error:[/bold red]'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nav/reference/settings/#dotflow.settings.Settings.INFO_ALERT","title":"<code>INFO_ALERT = f'{ICON} [bold blue]Info:[/bold blue]'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nav/reference/settings/#dotflow.settings.Settings.WARNING_ALERT","title":"<code>WARNING_ALERT = f'{ICON} [bold yellow]Warning:[/bold yellow]'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nav/reference/storage-file/","title":"StorageFile","text":""},{"location":"nav/reference/storage-file/#dotflow.providers.storage_file.StorageFile","title":"<code>dotflow.providers.storage_file.StorageFile</code>","text":"<p>               Bases: <code>Storage</code></p> <p>Storage</p> Source code in <code>dotflow/providers/storage_file.py</code> <pre><code>class StorageFile(Storage):\n    \"\"\"Storage\"\"\"\n\n    def __init__(self, *args, path: str = settings.START_PATH, **kwargs):\n        self.path = Path(path, \"tasks\")\n        self.path.mkdir(parents=True, exist_ok=True)\n\n    def post(self, key: str, context: Context) -&gt; None:\n        task_context = []\n\n        if Path(self.path, key).exists():\n            task_context = read_file(path=Path(self.path, key))\n\n        if isinstance(context.storage, list):\n            for item in context.storage:\n                if isinstance(item, Context):\n                    task_context.append(self._dumps(storage=item.storage))\n\n            write_file(path=Path(self.path, key), content=task_context, mode=\"a\")\n            return None\n\n        task_context.append(self._dumps(storage=context.storage))\n        write_file(path=Path(self.path, key), content=task_context)\n        return None\n\n    def get(self, key: str) -&gt; Context:\n        task_context = []\n\n        if Path(self.path, key).exists():\n            task_context = read_file(path=Path(self.path, key))\n\n        if len(task_context) == 1:\n            return self._loads(storage=task_context[0])\n\n        contexts = Context(storage=[])\n        for context in task_context:\n            contexts.storage.append(self._loads(storage=context))\n\n        return contexts\n\n    def key(self, task: Callable):\n        return f\"{task.workflow_id}-{task.task_id}.json\"\n\n    def _loads(self, storage: Any) -&gt; Context:\n        try:\n            return Context(storage=loads(storage))\n        except Exception:\n            return Context(storage=storage)\n\n    def _dumps(self, storage: Any) -&gt; str:\n        try:\n            return dumps(storage)\n        except TypeError:\n            return str(storage)\n</code></pre>"},{"location":"nav/reference/storage-file/#dotflow.providers.storage_file.StorageFile.path","title":"<code>path = Path(path, 'tasks')</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/storage-file/#dotflow.providers.storage_file.StorageFile.__init__","title":"<code>__init__(*args, path=settings.START_PATH, **kwargs)</code>","text":"Source code in <code>dotflow/providers/storage_file.py</code> <pre><code>def __init__(self, *args, path: str = settings.START_PATH, **kwargs):\n    self.path = Path(path, \"tasks\")\n    self.path.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"nav/reference/storage-file/#dotflow.providers.storage_file.StorageFile.get","title":"<code>get(key)</code>","text":"Source code in <code>dotflow/providers/storage_file.py</code> <pre><code>def get(self, key: str) -&gt; Context:\n    task_context = []\n\n    if Path(self.path, key).exists():\n        task_context = read_file(path=Path(self.path, key))\n\n    if len(task_context) == 1:\n        return self._loads(storage=task_context[0])\n\n    contexts = Context(storage=[])\n    for context in task_context:\n        contexts.storage.append(self._loads(storage=context))\n\n    return contexts\n</code></pre>"},{"location":"nav/reference/storage-file/#dotflow.providers.storage_file.StorageFile.key","title":"<code>key(task)</code>","text":"Source code in <code>dotflow/providers/storage_file.py</code> <pre><code>def key(self, task: Callable):\n    return f\"{task.workflow_id}-{task.task_id}.json\"\n</code></pre>"},{"location":"nav/reference/storage-file/#dotflow.providers.storage_file.StorageFile.post","title":"<code>post(key, context)</code>","text":"Source code in <code>dotflow/providers/storage_file.py</code> <pre><code>def post(self, key: str, context: Context) -&gt; None:\n    task_context = []\n\n    if Path(self.path, key).exists():\n        task_context = read_file(path=Path(self.path, key))\n\n    if isinstance(context.storage, list):\n        for item in context.storage:\n            if isinstance(item, Context):\n                task_context.append(self._dumps(storage=item.storage))\n\n        write_file(path=Path(self.path, key), content=task_context, mode=\"a\")\n        return None\n\n    task_context.append(self._dumps(storage=context.storage))\n    write_file(path=Path(self.path, key), content=task_context)\n    return None\n</code></pre>"},{"location":"nav/reference/storage-init/","title":"StorageDefault","text":""},{"location":"nav/reference/storage-init/#dotflow.providers.storage_default.StorageDefault","title":"<code>dotflow.providers.storage_default.StorageDefault</code>","text":"<p>               Bases: <code>Storage</code></p> <p>Storage</p> Source code in <code>dotflow/providers/storage_default.py</code> <pre><code>class StorageDefault(Storage):\n    \"\"\"Storage\"\"\"\n\n    def post(self, key: str, context: Context) -&gt; None:\n        return None\n\n    def get(self, key: str) -&gt; Context:\n        return Context(storage=cast(key, py_object).value)\n\n    def key(self, task: Callable):\n        return id(task.current_context)\n</code></pre>"},{"location":"nav/reference/storage-init/#dotflow.providers.storage_default.StorageDefault.get","title":"<code>get(key)</code>","text":"Source code in <code>dotflow/providers/storage_default.py</code> <pre><code>def get(self, key: str) -&gt; Context:\n    return Context(storage=cast(key, py_object).value)\n</code></pre>"},{"location":"nav/reference/storage-init/#dotflow.providers.storage_default.StorageDefault.key","title":"<code>key(task)</code>","text":"Source code in <code>dotflow/providers/storage_default.py</code> <pre><code>def key(self, task: Callable):\n    return id(task.current_context)\n</code></pre>"},{"location":"nav/reference/storage-init/#dotflow.providers.storage_default.StorageDefault.post","title":"<code>post(key, context)</code>","text":"Source code in <code>dotflow/providers/storage_default.py</code> <pre><code>def post(self, key: str, context: Context) -&gt; None:\n    return None\n</code></pre>"},{"location":"nav/reference/task-builder/","title":"TaskBuilder","text":""},{"location":"nav/reference/task-builder/#dotflow.core.task.TaskBuilder","title":"<code>dotflow.core.task.TaskBuilder</code>","text":"Import <p>You can import the Task class with:</p> <pre><code>from dotflow.core.task import TaskBuilder\n</code></pre> Example <p><code>class</code> dotflow.core.task.TaskBuilder</p> <pre><code>from uuid import uuid4\n\nbuild = TaskBuilder(\n    config=config\n    workflow_id=uuid4()\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>Configuration class.</p> required <code>workflow_id</code> <code>UUID</code> <p>Workflow ID.</p> <code>None</code> Source code in <code>dotflow/core/task.py</code> <pre><code>class TaskBuilder:\n    \"\"\"\n    Import:\n        You can import the **Task** class with:\n\n            from dotflow.core.task import TaskBuilder\n\n    Example:\n        `class` dotflow.core.task.TaskBuilder\n\n            from uuid import uuid4\n\n            build = TaskBuilder(\n                config=config\n                workflow_id=uuid4()\n            )\n\n    Args:\n        config (Config): Configuration class.\n        workflow_id (UUID): Workflow ID.\n    \"\"\"\n\n    def __init__(\n            self,\n            config: Config,\n            workflow_id: UUID = None\n    ) -&gt; None:\n        self.queue: List[Callable] = []\n        self.workflow_id = workflow_id\n        self.config = config\n\n    def add(\n        self,\n        step: Callable,\n        callback: Callable = basic_callback,\n        initial_context: Any = None,\n        group_name: str = \"default\"\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            step (Callable):\n                A argument that receives an object of the callable type,\n                which is basically a function. You can see in this\n                [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#3-task-function).\n\n            callback (Callable):\n                Any callable object that receives **args** or **kwargs**,\n                which is basically a function. You can see in this\n                [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#2-callback-function).\n\n            initial_context (Context):\n                The argument exists to include initial data in the execution\n                of the workflow within the **function context**. This parameter\n                can be accessed internally, for example: **initial_context**,\n                to retrieve this information and manipulate it if necessary,\n                according to the objective of the workflow.\n\n            group_name (str): Group name of tasks.\n        \"\"\"\n        if isinstance(step, list):\n            for inside_step in step:\n                self.add(\n                    step=inside_step,\n                    callback=callback,\n                    initial_context=initial_context,\n                    group_name=group_name\n                )\n            return self\n\n        self.queue.append(\n            Task(\n                task_id=len(self.queue),\n                step=step,\n                callback=Module(value=callback),\n                initial_context=initial_context,\n                workflow_id=self.workflow_id,\n                config=self.config,\n                group_name=group_name\n            )\n        )\n\n        return self\n\n    def count(self) -&gt; int:\n        return len(self.queue)\n\n    def clear(self) -&gt; None:\n        self.queue.clear()\n\n    def reverse(self) -&gt; None:\n        self.queue.reverse()\n\n    def schema(self) -&gt; SerializerWorkflow:\n        return SerializerWorkflow(\n            workflow_id=self.workflow_id,\n            tasks=[item.schema() for item in self.queue]\n        )\n\n    def result(self) -&gt; SerializerWorkflow:\n        item = self.schema().model_dump_json()\n        return json.loads(item)\n</code></pre>"},{"location":"nav/reference/task-builder/#dotflow.core.task.TaskBuilder.add","title":"<code>add(step, callback=basic_callback, initial_context=None, group_name='default')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>step</code> <code>Callable</code> <p>A argument that receives an object of the callable type, which is basically a function. You can see in this example.</p> required <code>callback</code> <code>Callable</code> <p>Any callable object that receives args or kwargs, which is basically a function. You can see in this example.</p> <code>basic_callback</code> <code>initial_context</code> <code>Context</code> <p>The argument exists to include initial data in the execution of the workflow within the function context. This parameter can be accessed internally, for example: initial_context, to retrieve this information and manipulate it if necessary, according to the objective of the workflow.</p> <code>None</code> <code>group_name</code> <code>str</code> <p>Group name of tasks.</p> <code>'default'</code> Source code in <code>dotflow/core/task.py</code> <pre><code>def add(\n    self,\n    step: Callable,\n    callback: Callable = basic_callback,\n    initial_context: Any = None,\n    group_name: str = \"default\"\n) -&gt; None:\n    \"\"\"\n    Args:\n        step (Callable):\n            A argument that receives an object of the callable type,\n            which is basically a function. You can see in this\n            [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#3-task-function).\n\n        callback (Callable):\n            Any callable object that receives **args** or **kwargs**,\n            which is basically a function. You can see in this\n            [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#2-callback-function).\n\n        initial_context (Context):\n            The argument exists to include initial data in the execution\n            of the workflow within the **function context**. This parameter\n            can be accessed internally, for example: **initial_context**,\n            to retrieve this information and manipulate it if necessary,\n            according to the objective of the workflow.\n\n        group_name (str): Group name of tasks.\n    \"\"\"\n    if isinstance(step, list):\n        for inside_step in step:\n            self.add(\n                step=inside_step,\n                callback=callback,\n                initial_context=initial_context,\n                group_name=group_name\n            )\n        return self\n\n    self.queue.append(\n        Task(\n            task_id=len(self.queue),\n            step=step,\n            callback=Module(value=callback),\n            initial_context=initial_context,\n            workflow_id=self.workflow_id,\n            config=self.config,\n            group_name=group_name\n        )\n    )\n\n    return self\n</code></pre>"},{"location":"nav/reference/task-builder/#dotflow.core.task.TaskBuilder.count","title":"<code>count()</code>","text":"Source code in <code>dotflow/core/task.py</code> <pre><code>def count(self) -&gt; int:\n    return len(self.queue)\n</code></pre>"},{"location":"nav/reference/task-builder/#dotflow.core.task.TaskBuilder.clear","title":"<code>clear()</code>","text":"Source code in <code>dotflow/core/task.py</code> <pre><code>def clear(self) -&gt; None:\n    self.queue.clear()\n</code></pre>"},{"location":"nav/reference/task-builder/#dotflow.core.task.TaskBuilder.reverse","title":"<code>reverse()</code>","text":"Source code in <code>dotflow/core/task.py</code> <pre><code>def reverse(self) -&gt; None:\n    self.queue.reverse()\n</code></pre>"},{"location":"nav/reference/task-error/","title":"TaskError","text":""},{"location":"nav/reference/task-error/#dotflow.core.task.TaskError","title":"<code>dotflow.core.task.TaskError</code>","text":"Source code in <code>dotflow/core/task.py</code> <pre><code>class TaskError:\n\n    def __init__(self, error: Exception = None) -&gt; None:\n        self.exception = error\n        self.traceback = traceback_error(error=error) if error else \"\"\n        self.message = message_error(error=error) if error else \"\"\n</code></pre>"},{"location":"nav/reference/task-error/#dotflow.core.task.TaskError.exception","title":"<code>exception = error</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task-error/#dotflow.core.task.TaskError.message","title":"<code>message = message_error(error=error) if error else ''</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task-error/#dotflow.core.task.TaskError.traceback","title":"<code>traceback = traceback_error(error=error) if error else ''</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task-error/#dotflow.core.task.TaskError.__init__","title":"<code>__init__(error=None)</code>","text":"Source code in <code>dotflow/core/task.py</code> <pre><code>def __init__(self, error: Exception = None) -&gt; None:\n    self.exception = error\n    self.traceback = traceback_error(error=error) if error else \"\"\n    self.message = message_error(error=error) if error else \"\"\n</code></pre>"},{"location":"nav/reference/task-instance/","title":"TaskInstance","text":""},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance","title":"<code>dotflow.core.task.TaskInstance</code>","text":"Import <p>You can import the TaskInstance class with:</p> <pre><code>from dotflow.core.task import TaskInstance\n</code></pre> Source code in <code>dotflow/core/task.py</code> <pre><code>class TaskInstance:\n    \"\"\"\n    Import:\n        You can import the **TaskInstance** class with:\n\n            from dotflow.core.task import TaskInstance\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -&gt; None:\n        self.task_id = None\n        self.workflow_id = None\n        self._step = None\n        self._callback = None\n        self._previous_context = None\n        self._initial_context = None\n        self._current_context = None\n        self._duration = None\n        self._error = None\n        self._status = None\n        self._config = None\n        self.group_name = None\n</code></pre>"},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance.task_id","title":"<code>task_id = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance.workflow_id","title":"<code>workflow_id = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._step","title":"<code>_step = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._callback","title":"<code>_callback = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._previous_context","title":"<code>_previous_context = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._initial_context","title":"<code>_initial_context = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._current_context","title":"<code>_current_context = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._duration","title":"<code>_duration = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._error","title":"<code>_error = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._status","title":"<code>_status = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance._config","title":"<code>_config = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task-instance/#dotflow.core.task.TaskInstance.group_name","title":"<code>group_name = None</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task/","title":"Task","text":""},{"location":"nav/reference/task/#dotflow.core.task.Task","title":"<code>dotflow.core.task.Task</code>","text":"<p>               Bases: <code>TaskInstance</code></p> Import <p>You can import the Task class directly from dotflow:</p> <pre><code>from dotflow import Task\n</code></pre> Example <p><code>class</code> dotflow.core.task.Task</p> <pre><code>task = Task(\n    task_id=1,\n    step=my_step,\n    callback=my_callback\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>Task ID.</p> required <code>step</code> <code>Callable</code> <p>A argument that receives an object of the callable type, which is basically a function. You can see in this example.</p> required <code>callback</code> <code>Callable</code> <p>Any callable object that receives args or kwargs, which is basically a function. You can see in this example.</p> <code>basic_callback</code> <code>initial_context</code> <code>Any</code> <p>Any python object.</p> <code>None</code> <code>workflow_id</code> <code>UUID</code> <p>Workflow ID.</p> <code>None</code> <code>config</code> <code>Config</code> <p>Configuration class.</p> <code>None</code> <code>group_name</code> <code>str</code> <p>Group name of tasks.</p> <code>'default'</code> Source code in <code>dotflow/core/task.py</code> <pre><code>class Task(TaskInstance):\n    \"\"\"\n    Import:\n        You can import the **Task** class directly from dotflow:\n\n            from dotflow import Task\n\n    Example:\n        `class` dotflow.core.task.Task\n\n            task = Task(\n                task_id=1,\n                step=my_step,\n                callback=my_callback\n            )\n\n    Args:\n        task_id (int): Task ID.\n\n        step (Callable):\n            A argument that receives an object of the callable type,\n            which is basically a function. You can see in this\n            [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#3-task-function).\n\n        callback (Callable):\n            Any callable object that receives **args** or **kwargs**,\n            which is basically a function. You can see in this\n            [example](https://dotflow-io.github.io/dotflow/nav/getting-started/#2-callback-function).\n\n        initial_context (Any): Any python object.\n\n        workflow_id (UUID): Workflow ID.\n\n        config (Config): Configuration class.\n\n        group_name (str): Group name of tasks.\n    \"\"\"\n\n    def __init__(\n        self,\n        task_id: int,\n        step: Callable,\n        callback: Callable = basic_callback,\n        initial_context: Any = None,\n        workflow_id: UUID = None,\n        config: Config = None,\n        group_name: str = \"default\"\n    ) -&gt; None:\n        super().__init__(\n            task_id,\n            step,\n            callback,\n            initial_context,\n            workflow_id,\n            config,\n            group_name\n        )\n        self.config = config\n        self.group_name = group_name\n        self.task_id = task_id\n        self.workflow_id = workflow_id\n        self.step = step\n        self.callback = callback\n        self.initial_context = initial_context\n        self.status = TypeStatus.NOT_STARTED\n\n    @property\n    def step(self):\n        return self._step\n\n    @step.setter\n    def step(self, value: Callable):\n        new_step = value\n\n        if isinstance(value, str):\n            new_step = Module(value=value)\n\n        if new_step.__module__ != Action.__module__:\n            raise MissingActionDecorator()\n\n        self._step = new_step\n\n    @property\n    def callback(self):\n        return self._callback\n\n    @callback.setter\n    def callback(self, value: Callable):\n        new_callback = value\n\n        if isinstance(value, str):\n            new_callback = Module(value=value)\n\n        if not isinstance(new_callback, Callable):\n            raise NotCallableObject(name=str(new_callback))\n\n        self._callback = new_callback\n\n    @property\n    def previous_context(self):\n        if not self._previous_context:\n            return Context()\n        return self._previous_context\n\n    @previous_context.setter\n    def previous_context(self, value: Context):\n        self._previous_context = Context(value)\n\n    @property\n    def initial_context(self):\n        if not self._initial_context:\n            return Context()\n        return self._initial_context\n\n    @initial_context.setter\n    def initial_context(self, value: Context):\n        self._initial_context = Context(value)\n\n    @property\n    def current_context(self):\n        if not self._current_context:\n            return Context()\n        return self._current_context\n\n    @current_context.setter\n    def current_context(self, value: Context):\n        self._current_context = Context(\n            task_id=self.task_id,\n            workflow_id=self.workflow_id,\n            storage=value\n        )\n\n        self.config.storage.post(\n            key=self.config.storage.key(task=self),\n            context=self.current_context\n        )\n\n    @property\n    def duration(self):\n        return self._duration\n\n    @duration.setter\n    def duration(self, value: float):\n        self._duration = value\n\n    @property\n    def error(self):\n        if not self._error:\n            return TaskError()\n        return self._error\n\n    @error.setter\n    def error(self, value: Exception) -&gt; None:\n        if isinstance(value, TaskError):\n            self._error = value\n\n        if isinstance(value, Exception):\n            task_error = TaskError(value)\n            self._error = task_error\n\n            self.config.log.error(task=self)\n\n    @property\n    def status(self):\n        if not self._status:\n            return TypeStatus.NOT_STARTED\n        return self._status\n\n    @status.setter\n    def status(self, value: TypeStatus) -&gt; None:\n        self._status = value\n\n        self.config.notify.send(task=self)\n        self.config.log.info(task=self)\n\n    @property\n    def config(self):\n        if not self._config:\n            return Config()\n        return self._config\n\n    @config.setter\n    def config(self, value: Config):\n        self._config = value\n\n    def schema(self, max: int = None) -&gt; SerializerTask:\n        return SerializerTask(**self.__dict__, max=max)\n\n    def result(self, max: int = None) -&gt; SerializerWorkflow:\n        item = self.schema(max=max).model_dump_json()\n        return json.loads(item)\n</code></pre>"},{"location":"nav/reference/task/#dotflow.core.task.Task.callback","title":"<code>callback</code>  <code>property</code> <code>writable</code>","text":""},{"location":"nav/reference/task/#dotflow.core.task.Task.config","title":"<code>config</code>  <code>property</code> <code>writable</code>","text":""},{"location":"nav/reference/task/#dotflow.core.task.Task.current_context","title":"<code>current_context</code>  <code>property</code> <code>writable</code>","text":""},{"location":"nav/reference/task/#dotflow.core.task.Task.duration","title":"<code>duration</code>  <code>property</code> <code>writable</code>","text":""},{"location":"nav/reference/task/#dotflow.core.task.Task.error","title":"<code>error</code>  <code>property</code> <code>writable</code>","text":""},{"location":"nav/reference/task/#dotflow.core.task.Task.group_name","title":"<code>group_name = group_name</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task/#dotflow.core.task.Task.initial_context","title":"<code>initial_context</code>  <code>property</code> <code>writable</code>","text":""},{"location":"nav/reference/task/#dotflow.core.task.Task.previous_context","title":"<code>previous_context</code>  <code>property</code> <code>writable</code>","text":""},{"location":"nav/reference/task/#dotflow.core.task.Task.status","title":"<code>status</code>  <code>property</code> <code>writable</code>","text":""},{"location":"nav/reference/task/#dotflow.core.task.Task.step","title":"<code>step</code>  <code>property</code> <code>writable</code>","text":""},{"location":"nav/reference/task/#dotflow.core.task.Task.task_id","title":"<code>task_id = task_id</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task/#dotflow.core.task.Task.workflow_id","title":"<code>workflow_id = workflow_id</code>  <code>instance-attribute</code>","text":""},{"location":"nav/reference/task/#dotflow.core.task.Task.__init__","title":"<code>__init__(task_id, step, callback=basic_callback, initial_context=None, workflow_id=None, config=None, group_name='default')</code>","text":"Source code in <code>dotflow/core/task.py</code> <pre><code>def __init__(\n    self,\n    task_id: int,\n    step: Callable,\n    callback: Callable = basic_callback,\n    initial_context: Any = None,\n    workflow_id: UUID = None,\n    config: Config = None,\n    group_name: str = \"default\"\n) -&gt; None:\n    super().__init__(\n        task_id,\n        step,\n        callback,\n        initial_context,\n        workflow_id,\n        config,\n        group_name\n    )\n    self.config = config\n    self.group_name = group_name\n    self.task_id = task_id\n    self.workflow_id = workflow_id\n    self.step = step\n    self.callback = callback\n    self.initial_context = initial_context\n    self.status = TypeStatus.NOT_STARTED\n</code></pre>"},{"location":"nav/reference/task/#dotflow.core.task.Task.result","title":"<code>result(max=None)</code>","text":"Source code in <code>dotflow/core/task.py</code> <pre><code>def result(self, max: int = None) -&gt; SerializerWorkflow:\n    item = self.schema(max=max).model_dump_json()\n    return json.loads(item)\n</code></pre>"},{"location":"nav/reference/task/#dotflow.core.task.Task.schema","title":"<code>schema(max=None)</code>","text":"Source code in <code>dotflow/core/task.py</code> <pre><code>def schema(self, max: int = None) -&gt; SerializerTask:\n    return SerializerTask(**self.__dict__, max=max)\n</code></pre>"},{"location":"nav/reference/type-execution/","title":"TypeExecution","text":""},{"location":"nav/reference/type-execution/#dotflow.core.types.execution.TypeExecution","title":"<code>dotflow.core.types.execution.TypeExecution</code>","text":"Import <p>You can import the TypeExecution class with:</p> <pre><code>from dotflow.core.types import TypeExecution\n</code></pre> Source code in <code>dotflow/core/types/execution.py</code> <pre><code>class TypeExecution:\n    \"\"\"\n    Import:\n        You can import the **TypeExecution** class with:\n\n            from dotflow.core.types import TypeExecution\n    \"\"\"\n\n    SEQUENTIAL: Annotated[str, Doc(\"Sequential execution.\")] = \"sequential\"\n    BACKGROUND:  Annotated[str, Doc(\"Background execution.\")] = \"background\"\n    PARALLEL:  Annotated[str, Doc(\"Parallel execution.\")] = \"parallel\"\n</code></pre>"},{"location":"nav/reference/type-execution/#dotflow.core.types.execution.TypeExecution.SEQUENTIAL","title":"<code>SEQUENTIAL = 'sequential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Sequential execution.</p>"},{"location":"nav/reference/type-execution/#dotflow.core.types.execution.TypeExecution.BACKGROUND","title":"<code>BACKGROUND = 'background'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Background execution.</p>"},{"location":"nav/reference/type-execution/#dotflow.core.types.execution.TypeExecution.PARALLEL","title":"<code>PARALLEL = 'parallel'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Parallel execution.</p>"},{"location":"nav/reference/type-status/","title":"TypeStatus","text":""},{"location":"nav/reference/type-status/#dotflow.core.types.status.TypeStatus","title":"<code>dotflow.core.types.status.TypeStatus</code>","text":"Import <p>You can import the TypeStatus class with:</p> <pre><code>from dotflow.core.types import TypeStatus\n</code></pre> Source code in <code>dotflow/core/types/status.py</code> <pre><code>class TypeStatus:\n    \"\"\"\n    Import:\n        You can import the **TypeStatus** class with:\n\n            from dotflow.core.types import TypeStatus\n    \"\"\"\n\n    NOT_STARTED: Annotated[str, Doc(\"Status not started.\")] = \"Not started\"\n    IN_PROGRESS: Annotated[str, Doc(\"Status in progress.\")] = \"In progress\"\n    COMPLETED: Annotated[str, Doc(\"Status completed.\")] = \"Completed\"\n    PAUSED: Annotated[str, Doc(\"Status paused.\")] = \"Paused\"\n    RETRY: Annotated[str, Doc(\"Status retry.\")] = \"Retry\"\n    FAILED: Annotated[str, Doc(\"Status failed.\")] = \"Failed\"\n\n    @classmethod\n    def get_symbol(cls, value: str) -&gt; str:\n        status = {\n           TypeStatus.NOT_STARTED: \"\u26aa\",\n           TypeStatus.IN_PROGRESS: \"\ud83d\udd35\",\n           TypeStatus.COMPLETED: \"\u2705\",\n           TypeStatus.PAUSED: \"\u25fc\ufe0f\",\n           TypeStatus.RETRY: \"\u2757\",\n           TypeStatus.FAILED: \"\u274c\"\n        }\n        return status.get(value)\n</code></pre>"},{"location":"nav/reference/type-status/#dotflow.core.types.status.TypeStatus.NOT_STARTED","title":"<code>NOT_STARTED = 'Not started'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Status not started.</p>"},{"location":"nav/reference/type-status/#dotflow.core.types.status.TypeStatus.IN_PROGRESS","title":"<code>IN_PROGRESS = 'In progress'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Status in progress.</p>"},{"location":"nav/reference/type-status/#dotflow.core.types.status.TypeStatus.COMPLETED","title":"<code>COMPLETED = 'Completed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Status completed.</p>"},{"location":"nav/reference/type-status/#dotflow.core.types.status.TypeStatus.PAUSED","title":"<code>PAUSED = 'Paused'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Status paused.</p>"},{"location":"nav/reference/type-status/#dotflow.core.types.status.TypeStatus.RETRY","title":"<code>RETRY = 'Retry'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Status retry.</p>"},{"location":"nav/reference/type-status/#dotflow.core.types.status.TypeStatus.FAILED","title":"<code>FAILED = 'Failed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Status failed.</p>"},{"location":"nav/reference/utils/","title":"Utils","text":""},{"location":"nav/reference/utils/#dotflow.utils.basic_functions.basic_function","title":"<code>dotflow.utils.basic_functions.basic_function(*args, **kwargs)</code>","text":"Source code in <code>dotflow/utils/basic_functions.py</code> <pre><code>def basic_function(*args, **kwargs) -&gt; None:\n    pass\n</code></pre>"},{"location":"nav/reference/utils/#dotflow.utils.basic_functions.basic_callback","title":"<code>dotflow.utils.basic_functions.basic_callback(*args, **kwargs)</code>","text":"Source code in <code>dotflow/utils/basic_functions.py</code> <pre><code>def basic_callback(*args, **kwargs) -&gt; None:\n    pass\n</code></pre>"},{"location":"nav/reference/workflow/","title":"Manager","text":""},{"location":"nav/reference/workflow/#dotflow.core.workflow.Manager","title":"<code>dotflow.core.workflow.Manager</code>","text":"Import <p>You can import the Manager class with:</p> <pre><code>from dotflow.core.workflow import Manager\n</code></pre> Example <p><code>class</code> dotflow.core.workflow.Manager</p> <pre><code>workflow = Manager(\n    tasks=[tasks],\n    on_success=basic_callback,\n    on_failure=basic_callback,\n    keep_going=True\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>List[Task]</code> <p>A list containing objects of type Task.</p> required <code>on_success</code> <code>Callable</code> <p>Success function to be executed after the completion of the entire workflow. It's essentially a callback for successful scenarios.</p> <code>basic_callback</code> <code>on_failure</code> <code>Callable</code> <p>Failure function to be executed after the completion of the entire workflow. It's essentially a callback for error scenarios</p> <code>basic_callback</code> <code>mode</code> <code>TypeExecution</code> <p>Parameter that defines the execution mode of the workflow. Currently, there are options to execute in sequential, background, or parallel mode. The sequential mode is used by default.</p> <code>SEQUENTIAL</code> <code>keep_going</code> <code>bool</code> <p>A parameter that receives a boolean object with the purpose of continuing or not the execution of the workflow in case of an error during the execution of a task. If it is true, the execution will continue; if it is False, the workflow will stop.</p> <code>False</code> <code>workflow_id</code> <code>UUID</code> <p>Workflow ID.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>on_success</code> <code>Callable</code> <code>on_failure</code> <code>Callable</code> <code>workflow_id</code> <code>UUID</code> <code>started</code> <code>datetime</code> Source code in <code>dotflow/core/workflow.py</code> <pre><code>class Manager:\n    \"\"\"\n    Import:\n        You can import the **Manager** class with:\n\n            from dotflow.core.workflow import Manager\n\n    Example:\n        `class` dotflow.core.workflow.Manager\n\n            workflow = Manager(\n                tasks=[tasks],\n                on_success=basic_callback,\n                on_failure=basic_callback,\n                keep_going=True\n            )\n\n    Args:\n        tasks (List[Task]):\n            A list containing objects of type Task.\n\n        on_success (Callable):\n            Success function to be executed after the completion of the entire\n            workflow. It's essentially a callback for successful scenarios.\n\n        on_failure (Callable):\n            Failure function to be executed after the completion of the entire\n            workflow. It's essentially a callback for error scenarios\n\n        mode (TypeExecution):\n            Parameter that defines the execution mode of the workflow. Currently,\n            there are options to execute in **sequential**, **background**, or **parallel** mode.\n            The sequential mode is used by default.\n\n\n        keep_going (bool):\n            A parameter that receives a boolean object with the purpose of continuing\n            or not the execution of the workflow in case of an error during the\n            execution of a task. If it is **true**, the execution will continue;\n            if it is **False**, the workflow will stop.\n\n        workflow_id (UUID): Workflow ID.\n\n    Attributes:\n        on_success (Callable):\n\n        on_failure (Callable):\n\n        workflow_id (UUID):\n\n        started (datetime):\n    \"\"\"\n\n    def __init__(\n        self,\n        tasks: List[Task],\n        on_success: Callable = basic_callback,\n        on_failure: Callable = basic_callback,\n        mode: TypeExecution = TypeExecution.SEQUENTIAL,\n        keep_going: bool = False,\n        workflow_id: UUID = None,\n    ) -&gt; None:\n        self.tasks = tasks\n        self.on_success = on_success\n        self.on_failure = on_failure\n        self.workflow_id = workflow_id or uuid4()\n        self.started = datetime.now()\n\n        execution = None\n        groups = grouper(tasks=tasks)\n\n        try:\n            execution = getattr(self, mode)\n        except AttributeError as err:\n            raise ExecutionModeNotExist() from err\n\n        self.tasks = execution(\n            tasks=tasks, workflow_id=workflow_id, ignore=keep_going, groups=groups\n        )\n\n        self._callback_workflow(tasks=self.tasks)\n\n    def _callback_workflow(self, tasks: List[Task]):\n        final_status = [task.status for task in tasks]\n\n        if TypeStatus.FAILED in final_status:\n            self.on_failure(tasks=tasks)\n        else:\n            self.on_success(tasks=tasks)\n\n    def sequential(self, **kwargs) -&gt; List[Task]:\n        if len(kwargs.get(\"groups\", {})) &gt; 1 and not is_darwin():\n            process = SequentialGroup(**kwargs)\n            return process.get_tasks()\n\n        process = Sequential(**kwargs)\n        return process.get_tasks()\n\n    def sequential_group(self, **kwargs):\n        process = SequentialGroup(**kwargs)\n        return process.get_tasks()\n\n    def background(self, **kwargs) -&gt; List[Task]:\n        process = Background(**kwargs)\n        return process.get_tasks()\n\n    def parallel(self, **kwargs) -&gt; List[Task]:\n        if is_darwin():\n            warnings.warn(\n                \"Parallel mode does not work with MacOS.\"\n                \" Running tasks in sequence.\",\n                Warning\n            )\n            process = Sequential(**kwargs)\n            return process.get_tasks()\n\n        process = Parallel(**kwargs)\n        return process.get_tasks()\n</code></pre>"},{"location":"nav/reference/workflow/#dotflow.core.workflow.Manager._callback_workflow","title":"<code>_callback_workflow(tasks)</code>","text":"Source code in <code>dotflow/core/workflow.py</code> <pre><code>def _callback_workflow(self, tasks: List[Task]):\n    final_status = [task.status for task in tasks]\n\n    if TypeStatus.FAILED in final_status:\n        self.on_failure(tasks=tasks)\n    else:\n        self.on_success(tasks=tasks)\n</code></pre>"},{"location":"nav/reference/workflow/#dotflow.core.workflow.Manager.sequential","title":"<code>sequential(**kwargs)</code>","text":"Source code in <code>dotflow/core/workflow.py</code> <pre><code>def sequential(self, **kwargs) -&gt; List[Task]:\n    if len(kwargs.get(\"groups\", {})) &gt; 1 and not is_darwin():\n        process = SequentialGroup(**kwargs)\n        return process.get_tasks()\n\n    process = Sequential(**kwargs)\n    return process.get_tasks()\n</code></pre>"},{"location":"nav/reference/workflow/#dotflow.core.workflow.Manager.background","title":"<code>background(**kwargs)</code>","text":"Source code in <code>dotflow/core/workflow.py</code> <pre><code>def background(self, **kwargs) -&gt; List[Task]:\n    process = Background(**kwargs)\n    return process.get_tasks()\n</code></pre>"},{"location":"nav/reference/workflow/#dotflow.core.workflow.Manager.parallel","title":"<code>parallel(**kwargs)</code>","text":"Source code in <code>dotflow/core/workflow.py</code> <pre><code>def parallel(self, **kwargs) -&gt; List[Task]:\n    if is_darwin():\n        warnings.warn(\n            \"Parallel mode does not work with MacOS.\"\n            \" Running tasks in sequence.\",\n            Warning\n        )\n        process = Sequential(**kwargs)\n        return process.get_tasks()\n\n    process = Parallel(**kwargs)\n    return process.get_tasks()\n</code></pre>"},{"location":"nav/tutorial/first-steps/","title":"First Steps","text":""},{"location":"nav/tutorial/first-steps/#1-import","title":"1. Import","text":"<p>Start with the basics, which is importing the necessary classes and methods. (DotFlow, action)</p> Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n# Code below omitted \ud83d\udc47\n</code></pre> \ud83d\udc40 Full file preview Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n\ndef my_callback(*args, **kwargs):\n    print(args, kwargs)\n\n\n@action\ndef my_task():\n    print(\"task\")\n\n\nworkflow = DotFlow()\nworkflow.task.add(step=my_task, callback=my_callback)\nworkflow.start()\n</code></pre>"},{"location":"nav/tutorial/first-steps/#2-callback-function","title":"2. Callback function","text":"<p>Create a <code>my_callback</code> function to receive execution information of a task. <code>It is not necessary</code> to include this function, as you will still have a report at the end of the execution in the instantiated object of the <code>DotFlow</code> class. This <code>my_callback</code> function is only needed if you need to do something after the execution of the task, for example: sending a message to someone, making a phone call, or sending a letter. More details</p> Python 3.8+ <pre><code># Code above omitted \ud83d\udc46\n\ndef my_callback(*args, **kwargs):\n    print(args, kwargs)\n\n# Code below omitted \ud83d\udc47\n</code></pre> \ud83d\udc40 Full file preview Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n\ndef my_callback(*args, **kwargs):\n    print(args, kwargs)\n\n\n@action\ndef my_task():\n    print(\"task\")\n\n\nworkflow = DotFlow()\nworkflow.task.add(step=my_task, callback=my_callback)\nworkflow.start()\n</code></pre>"},{"location":"nav/tutorial/first-steps/#3-task-function","title":"3. Task function","text":"<p>Now, create the function responsible for executing your task. It's very simple; just use the action decorator above the function, and that's it\u2014you've created a task.</p> Python 3.8+ <pre><code># Code above omitted \ud83d\udc46\n\n@action\ndef my_task():\n    print(\"task\")\n\n# Code below omitted \ud83d\udc47\n</code></pre> \ud83d\udc40 Full file preview Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n\ndef my_callback(*args, **kwargs):\n    print(args, kwargs)\n\n\n@action\ndef my_task():\n    print(\"task\")\n\n\nworkflow = DotFlow()\nworkflow.task.add(step=my_task, callback=my_callback)\nworkflow.start()\n</code></pre>"},{"location":"nav/tutorial/first-steps/#4-dotflow-class","title":"4. DotFlow Class","text":"<p>Instantiate the DotFlow class in a <code>workflow</code> variable to be used in the following steps. More details.</p> Python 3.8+ <pre><code># Code above omitted \ud83d\udc46\n\nworkflow = DotFlow()\n\n# Code below omitted \ud83d\udc47\n</code></pre> \ud83d\udc40 Full file preview Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n\ndef my_callback(*args, **kwargs):\n    print(args, kwargs)\n\n\n@action\ndef my_task():\n    print(\"task\")\n\n\nworkflow = DotFlow()\nworkflow.task.add(step=my_task, callback=my_callback)\nworkflow.start()\n</code></pre>"},{"location":"nav/tutorial/first-steps/#5-add-task","title":"5. Add Task","text":"<p>Now, simply add the <code>my_task</code> and <code>my_callback</code> functions you created earlier to the workflow using the code below. This process is necessary to define which tasks will be executed and the order in which they will run. The execution order follows the sequence in which they were added to the workflow. More details</p> Python 3.8+ <pre><code># Code above omitted \ud83d\udc46\n\nworkflow.task.add(step=my_task, callback=my_callback)\n\n# Code below omitted \ud83d\udc47\n</code></pre> \ud83d\udc40 Full file preview Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n\ndef my_callback(*args, **kwargs):\n    print(args, kwargs)\n\n\n@action\ndef my_task():\n    print(\"task\")\n\n\nworkflow = DotFlow()\nworkflow.task.add(step=my_task, callback=my_callback)\nworkflow.start()\n</code></pre>"},{"location":"nav/tutorial/first-steps/#6-start","title":"6. Start","text":"<p>Finally, just execute the workflow with the following code snippet. More details</p> Python 3.8+ <pre><code># Code above omitted \ud83d\udc46\n\nworkflow.start()\n</code></pre> \ud83d\udc40 Full file preview Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n\ndef my_callback(*args, **kwargs):\n    print(args, kwargs)\n\n\n@action\ndef my_task():\n    print(\"task\")\n\n\nworkflow = DotFlow()\nworkflow.task.add(step=my_task, callback=my_callback)\nworkflow.start()\n</code></pre>"},{"location":"nav/tutorial/first-steps/#full-code","title":"Full Code","text":"<p>The simplest file could look like this:</p> Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n\ndef my_callback(*args, **kwargs):\n    print(args, kwargs)\n\n\n@action\ndef my_task():\n    print(\"task\")\n\n\nworkflow = DotFlow()\nworkflow.task.add(step=my_task, callback=my_callback)\nworkflow.start()\n</code></pre>"},{"location":"nav/tutorial/initial-context/","title":"Initial Context","text":""},{"location":"nav/tutorial/initial-context/#sending-context","title":"Sending context:","text":"<p>The initial context can be sent when adding a task to the queue using the <code>initial_context</code> attribute.</p> Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n\n@action\ndef extract_task(initial_context):\n    print(initial_context.storage, \"extract\")\n    assert initial_context.storage == {\"foo\": True}\n\n    return \"extract\"\n\n\n@action\ndef transform_task(initial_context):\n    print(initial_context.storage, \"transform\")\n    assert initial_context.storage == {\"bar\": True}\n\n    return \"transform\"\n\n\n@action\ndef load_task():\n    return \"load\"\n\n\ndef main():\n    workflow = DotFlow()\n\n    workflow.task.add(step=extract_task, initial_context={\"foo\": True})\n    workflow.task.add(step=transform_task, initial_context={\"bar\": True})\n    workflow.task.add(step=load_task)\n\n    workflow.start()\n\n    return workflow\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"nav/tutorial/initial-context/#receiving-context","title":"Receiving context","text":"<p>In this example, an initial context value is received from the <code>initial_context</code> attribute defined in the function.</p> Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n\n@action\ndef extract_task(initial_context):\n    print(initial_context.storage, \"extract\")\n    assert initial_context.storage == {\"foo\": True}\n\n    return \"extract\"\n\n\n@action\ndef transform_task(initial_context):\n    print(initial_context.storage, \"transform\")\n    assert initial_context.storage == {\"bar\": True}\n\n    return \"transform\"\n\n\n@action\ndef load_task():\n    return \"load\"\n\n\ndef main():\n    workflow = DotFlow()\n\n    workflow.task.add(step=extract_task, initial_context={\"foo\": True})\n    workflow.task.add(step=transform_task, initial_context={\"bar\": True})\n    workflow.task.add(step=load_task)\n\n    workflow.start()\n\n    return workflow\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"nav/tutorial/install/","title":"Install","text":"<p>To install Dotflow, run the following command from the command line:</p>"},{"location":"nav/tutorial/install/#with-pip","title":"With Pip","text":"<pre><code>pip install dotflow\n</code></pre>"},{"location":"nav/tutorial/install/#with-poetry","title":"With Poetry","text":"<pre><code>poetry add dotflow\n</code></pre>"},{"location":"nav/tutorial/previous-context/","title":"Previous Context","text":""},{"location":"nav/tutorial/previous-context/#sending-context","title":"Sending context:","text":"<p>To send a context, just return some information in your task implementation. You can return any object, and it will become part of the context.</p> Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n\n@action\ndef extract_task():\n    print(\"extract\")\n    return \"extract\"\n\n\n@action\ndef transform_task(previous_context):\n    print(previous_context.storage, \"transform\")\n    assert previous_context.storage == \"extract\"\n\n    return \"transform\"\n\n\n@action\ndef load_task(previous_context):\n    print(previous_context.storage, \"load\")\n    assert previous_context.storage == \"transform\"\n\n    return \"load\"\n\n\ndef main():\n    workflow = DotFlow()\n\n    workflow.task.add(step=extract_task)\n    workflow.task.add(step=transform_task)\n    workflow.task.add(step=load_task)\n\n    workflow.start()\n\n    return workflow\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"nav/tutorial/previous-context/#receiving-context","title":"Receiving context","text":"<p>In this example, an previous context value is received from the <code>previous_contexto</code> attribute defined in the function.</p> Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n\n@action\ndef extract_task():\n    print(\"extract\")\n    return \"extract\"\n\n\n@action\ndef transform_task(previous_context):\n    print(previous_context.storage, \"transform\")\n    assert previous_context.storage == \"extract\"\n\n    return \"transform\"\n\n\n@action\ndef load_task(previous_context):\n    print(previous_context.storage, \"load\")\n    assert previous_context.storage == \"transform\"\n\n    return \"load\"\n\n\ndef main():\n    workflow = DotFlow()\n\n    workflow.task.add(step=extract_task)\n    workflow.task.add(step=transform_task)\n    workflow.task.add(step=load_task)\n\n    workflow.start()\n\n    return workflow\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"pt/","title":"Bem-vindo ao Dotflow","text":"Website   \u00a0\u2022\u00a0   Documenta\u00e7\u00e3o   \u00a0\u2022\u00a0   Pypi <p>Com o Dotflow, voc\u00ea tem em m\u00e3os uma biblioteca poderosa e f\u00e1cil de usar, projetada para criar pipelines de execu\u00e7\u00e3o sem complica\u00e7\u00e3o. Adicione tarefas de forma intuitiva e controle todo o processo com apenas alguns comandos.</p> <p>Nosso objetivo \u00e9 tornar o gerenciamento de tarefas mais r\u00e1pido e seguro, sem sobrecarregar voc\u00ea com complexidade. Basta instanciar a classe DotFlow, adicionar suas tarefas com o m\u00e9todo <code>add</code> e iniciar a execu\u00e7\u00e3o com o m\u00e9todo <code>start</code>.</p> <p>Comece pelo b\u00e1sico aqui.</p>"},{"location":"pt/#obtendo-ajuda","title":"Obtendo Ajuda","text":"<p>Utilizamos issues do GitHub para rastrear bugs e solicita\u00e7\u00f5es de funcionalidades, e temos um tempo limitado para lidar com elas. Se precisar de algo, pedimos que siga nossos modelos para abrir issues ou discuss\u00f5es.</p> <ul> <li>\ud83d\udc1b Relatar Bug</li> <li>\ud83d\udcd5 Documenta\u00e7\u00e3o</li> <li>\ud83d\ude80 Solicitar Funcionalidade</li> <li>\u26a0\ufe0f Problema de Seguran\u00e7a</li> <li>\ud83d\udcac Pergunta Geral</li> </ul>"},{"location":"pt/#estilo-de-commit","title":"Estilo de Commit","text":"\u00cdcone Tipo Descri\u00e7\u00e3o \u2699\ufe0f FEATURE Nova funcionalidade \ud83d\udcdd PEP8 Ajustes de formata\u00e7\u00e3o seguindo PEP8 \ud83d\udccc ISSUE Refer\u00eancia a issue \ud83e\udeb2 BUG Corre\u00e7\u00e3o de erro \ud83d\udcd8 DOCS Altera\u00e7\u00f5es na documenta\u00e7\u00e3o \ud83d\udce6 PyPI Publica\u00e7\u00f5es no PyPI \u2764\ufe0f\ufe0f TEST Testes automatizados \u2b06\ufe0f CI/CD Altera\u00e7\u00f5es em integra\u00e7\u00e3o/entrega cont\u00ednua \u26a0\ufe0f SECURITY Melhorias de seguran\u00e7a"},{"location":"pt/#licenca","title":"Licen\u00e7a","text":"<p>Este projeto est\u00e1 licenciado sob os termos da Licen\u00e7a MIT.</p>"},{"location":"pt/nav/learn/","title":"Aprender","text":"<p>Nesta parte da documenta\u00e7\u00e3o encontramos as se\u00e7\u00f5es introdut\u00f3rias e os tutoriais para aprendermos como usar o Dotflow.</p>"},{"location":"pt/nav/learn/concept-of-context/","title":"Conceito de Contexto","text":"<p>Quando \u00e9 referido sobre Contexto dentro da biblioteca Dotflow estamos falando de como os dados sao trafegados dentro das tarefas. O Contexto \u00e9 basicamente uma classe embutida em todo retorna de uma tarefa, essa classe \u00e9 padronizada e voce pode acessar o valor dela com o objeto <code>storage</code>.</p> <p>Note</p> <p>O padrao da classe Contexto \u00e9 atribuido ao Contexto Incial e Contexto Anterior de uma tarefa. </p>"},{"location":"pt/nav/learn/concept-of-context/#acesssando-os-dados-do-contexto","title":"Acesssando os dados do Contexto","text":"Python 3.8+ <pre><code>from dotflow import Context\n\nnew_context = Context(\n    storage={\"data\": [0, 1, 2, 3]}\n)\n\nprint(new_context.time)\nprint(new_context.task_id)\nprint(new_context.workflow_id)\nprint(new_context.storage)\n</code></pre> <p>Para detalhes sobre a implementa\u00e7\u00e3o da classe, voc\u00ea pode acessar aqui.</p>"},{"location":"pt/nav/tutorial-user-guide/initial-context/","title":"Contexto Inicial","text":""},{"location":"pt/nav/tutorial-user-guide/initial-context/#enviando-contexto","title":"Enviando Contexto:","text":"<p>O contexto inicial pode ser enviado ao adicionar uma tarefa \u00e0 fila usando o atributo <code>initial_context</code>.</p> Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n\n@action\ndef extract_task(initial_context):\n    print(initial_context.storage, \"extract\")\n    assert initial_context.storage == {\"foo\": True}\n\n    return \"extract\"\n\n\n@action\ndef transform_task(initial_context):\n    print(initial_context.storage, \"transform\")\n    assert initial_context.storage == {\"bar\": True}\n\n    return \"transform\"\n\n\n@action\ndef load_task():\n    return \"load\"\n\n\ndef main():\n    workflow = DotFlow()\n\n    workflow.task.add(step=extract_task, initial_context={\"foo\": True})\n    workflow.task.add(step=transform_task, initial_context={\"bar\": True})\n    workflow.task.add(step=load_task)\n\n    workflow.start()\n\n    return workflow\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"pt/nav/tutorial-user-guide/initial-context/#recebendo-contexto","title":"Recebendo Contexto","text":"<p>Neste exemplo, um valor de contexto inicial \u00e9 recebido a partir do atributo <code>initial_context</code> definido na fun\u00e7\u00e3o.</p> Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n\n@action\ndef extract_task(initial_context):\n    print(initial_context.storage, \"extract\")\n    assert initial_context.storage == {\"foo\": True}\n\n    return \"extract\"\n\n\n@action\ndef transform_task(initial_context):\n    print(initial_context.storage, \"transform\")\n    assert initial_context.storage == {\"bar\": True}\n\n    return \"transform\"\n\n\n@action\ndef load_task():\n    return \"load\"\n\n\ndef main():\n    workflow = DotFlow()\n\n    workflow.task.add(step=extract_task, initial_context={\"foo\": True})\n    workflow.task.add(step=transform_task, initial_context={\"bar\": True})\n    workflow.task.add(step=load_task)\n\n    workflow.start()\n\n    return workflow\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"pt/nav/tutorial-user-guide/previous-context/","title":"Contexto Anterior","text":""},{"location":"pt/nav/tutorial-user-guide/previous-context/#enviando-contexto","title":"Enviando Contexto:","text":"<p>Para enviar um contexto, basta retornar alguma informa\u00e7\u00e3o na implementa\u00e7\u00e3o da sua tarefa. Voc\u00ea pode retornar qualquer objeto, e ele far\u00e1 parte do contexto.</p> Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n\n@action\ndef extract_task():\n    print(\"extract\")\n    return \"extract\"\n\n\n@action\ndef transform_task(previous_context):\n    print(previous_context.storage, \"transform\")\n    assert previous_context.storage == \"extract\"\n\n    return \"transform\"\n\n\n@action\ndef load_task(previous_context):\n    print(previous_context.storage, \"load\")\n    assert previous_context.storage == \"transform\"\n\n    return \"load\"\n\n\ndef main():\n    workflow = DotFlow()\n\n    workflow.task.add(step=extract_task)\n    workflow.task.add(step=transform_task)\n    workflow.task.add(step=load_task)\n\n    workflow.start()\n\n    return workflow\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"pt/nav/tutorial-user-guide/previous-context/#recebendo-contexto","title":"Recebendo Contexto","text":"<p>Neste exemplo, um valor de contexto anterior \u00e9 recebido a partir do atributo <code>previous_contexto</code> definido na fun\u00e7\u00e3o.</p> Python 3.8+ <pre><code>from dotflow import DotFlow, action\n\n\n@action\ndef extract_task():\n    print(\"extract\")\n    return \"extract\"\n\n\n@action\ndef transform_task(previous_context):\n    print(previous_context.storage, \"transform\")\n    assert previous_context.storage == \"extract\"\n\n    return \"transform\"\n\n\n@action\ndef load_task(previous_context):\n    print(previous_context.storage, \"load\")\n    assert previous_context.storage == \"transform\"\n\n    return \"load\"\n\n\ndef main():\n    workflow = DotFlow()\n\n    workflow.task.add(step=extract_task)\n    workflow.task.add(step=transform_task)\n    workflow.task.add(step=load_task)\n\n    workflow.start()\n\n    return workflow\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"}]}